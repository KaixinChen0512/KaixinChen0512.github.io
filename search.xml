<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端面试系列（一）：网站优化的解决方案]]></title>
    <url>%2FSEO.html</url>
    <content type="text"><![CDATA[该系列是博主研究生即将毕业寻觅工作之际，为更好充实自己的知识库，在网络上和项目中总结的大量经验，现分享出来，愿大家能一同进步。有些地方可能因为时间问题浅尝辄止，各位看客若有疑问或建议，皆可通过站内的联系方式或留言与我交流。 文件合并（目的是减少http请求）Web性能优化最佳实践中最重要的一条是减少HTTP 请求，减少HTTP请求的方案主要有合并JavaScript和CSS文件、CSS Sprites、图像映射 （Image Map）和使用Data URI来编码图片。 图像映射（Image Map）在标签内使用usemap属性制定一个标签的id；然后在标签内添加不同的标签，每个标签内有shape属性（可定义为rect、circle、poly）、coords属性（代表不同shape的定位）、href属性、alt属性等。即可实现在一张图上的不同区域能够映射不同的图像地址。 Data URL编码图片通常在标签中使用图片是采用src属性指定一个远程服务器上的资源。当页面加载时，浏览器会针对每个资源向服务器发送一个请求，一般浏览器并发请求数不能超过4个。因此大量使用会导致页面的加载延迟。使用Data URL将图片以base64字符串的格式嵌入至src属性，则不会产生请求。（IE6/7不支持）优势：当访问外部资源很麻烦或受限时、当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时、当图片的体积太小，占用一个HTTP会话不是很值得时使用。劣势：Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3；Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。如何避免劣势：在CSS中使用Data URL。通过CSS文件中的backround-image属性引用图片url地址：background-image: url(“data:XXX “);他避免了图片单独产生一次HTTP请求，又让图片随CSS被浏览器缓存（所有浏览器都很乐意缓存CSS文件）。如何使用：在线Data URL生成工具、使用HTML5的FileReader()（详见HTML5新特性中的文件接口） 使用CDN托管CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。最常用的将js库文件地址替换成百度CDN或者BootCDN的地址，其他的图片等就得花钱去买例如百度云CDN。 文件压缩使用YUI Compressor压缩JS/CSS文件；用GZip压缩文件，GZip的压缩之后所有文件都应该能减少30%以上的体积。特别是对于大量使用js的博客有了gzip保驾护航之后速度能提高不少。 缓存的使用详见文章：HTML5常用新特性中的应用程序缓存。 图片使用懒加载首先将网页内的标签内的src属性设为空，将图片的链接放入data-src中，并设置宽高（防止reflow），然后在js中进行判断，只有当页面滚动到某个所在的位置时，再将data-src中的地址赋值给img的src。可以利用JQueryLazyload或者echo.js实现。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>seo</tag>
        <tag>计算机网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一款响应式的网站Demo]]></title>
    <url>%2Fresponsive-web.html</url>
    <content type="text"><![CDATA[提问：如何才能提高我的GitHub的star和follow数呢？ 本作品原始灵感来源慕课网实战视频，如果大家有需要可以star我的GitHub，里面还有许多实战的源码，之后也会不断更新。接下来记录一些编程当中的重难点 viewport视口对于PC端：视口就是浏览器主窗口的区域对于手机端：layout port布局视口：一个虚拟的视口，一般是960px来把页面先进行渲染visual port可视视口：一个网页在手机上呈现出来的区域的宽度，用户的缩放会改变可视视口的大小，不会改变布局视口的大小ideal port理想视口：布局视口在一个设备上的最佳尺寸，理想视口下的页面便于浏览器的浏览和阅读（针对移动端），即设置使得布局视口等于可视视口，这样布局视口就成为了理想视口，若不指定则会是厂商默认的可能960px的布局视口相当于用放大镜（可视视口）来看书（布局视口） 清除浮动场景：父元素container里的p和div设置了float，则父元素会发生高度塌陷 方法1：在父元素内最后的位置添加一个div，style设为clear=both。但是添加了一个废的标签，不利于维护。 方法2：给父元素添加一个overflow：auto或者hidden,因为这样浮动的元素又会回到容器内，撑起容器的高度 方法3：给浮动元素的容器添加浮动属性也能够解决内部浮动的效果，但是父元素也产生了同样的问题 方法4：类似于第一种方法，在父元素的最后添加一个看不见的伪元素（一个冒号和两个冒号都可以，要求新伪元素用两个冒号如::selection，在这里使用一个，兼容性比较好） 12345678910.clearfix:after &#123; content: '.'; display: block; height: 0;/*避免生成的元素破坏原有的高度*/ clear: both;/*清除浮动*/ visibility: hidden;/*让生成的元素不可见*/&#125;.clearfix &#123; zoom: 1;&#125; zoom是IE专用属性，firefox等是不支持的。它的本来作用是设置或检索对象的缩放比例，但这作用几乎用不到。可以让网页实现IE7中的放大缩小功能。比如你想让你的网页缩小为原来的一半，那么就在body中加入style=”zoom:0.5”为了兼容IE6、7，因为只有令zoom=1才能够出发hasLayout，才能够达到清除浮动 方法5：根据BFC的概念，以下属性都能触发BFC，达到清除浮动 1234567float: left;/*除了none*/ overflow: auto;/* 除了visible*/ display: inline-block; display: table-cell; display: table-caption; position: fixed; position: absolute; 方法4中太多语句与清除浮动无关，可以改进的更优雅12345.clearfix:before,/*防止浏览器顶部的空白崩溃，即下面元素的margin-top和上面元素的margin-bottom发生叠加*/.clearfix:after &#123; content: " "; display: table;/*创造一个匿名的表格单元触发BFC*/&#125; 响应式图片的实现方法1：利用js或者服务器来实现（命令式的实现）通过$(window).on(‘resize load’, makeImageResponsive)来对浏览器窗口的调整绑定一个事件，事件里通过获取$(window).width()，并判断他的大小来动态的通过img.attr(‘src’,’XXX’)来设置img的src属性。方法2：使用srcset来实现（声明式的实现）在img标签中添加srcset属性，例如下：1&lt;img src="XXX.png" srcset="img/480.png 480w, img/800.png 800w"/&gt;//其中480w对应宽度为480px。 不足： 当浏览器已经加载过大图片时，调整会小窗口仍旧会默认使用大图。 当图片父容器宽度不是100%，比如50%时，图片宽度设为100%，此时窗口480w时，图片只有240w，但仍旧会按照480w去调整。方法3：配合sizes使用srcset（一组条件的匹配）在img标签中再添加sizes属性（默认为100vm，即使用100%视口宽度去选择图片）例：sizes=”(min-width:800px), 800w, 100vw”表示视口宽度大于800px时，都是用800宽度的图片，其余时候使用100%视口宽度去选择图片。（实际应用时，800w这里通常使用clac()动态计算，因为有边框间距等因素） 123456&lt;img sizes="(min-width: 40em) 80vw, 100vw" srcset="examples/images/medium.jpg 375w, examples/images/large.jpg 480w, examples/images/extralarge.jpg 768w" alt="…"&gt; 方法4：使用source，通过媒体查询设置不同的图片（多组条件的匹配）浏览器会像对audio和video标签一样去遍历所有source。例：12345&lt;picture&gt; &lt;source srcset="img/ad001-l.png" media="(min-width:50em)"&gt; &lt;source srcset="img/ad001-m.png" media="(min-width:30em)"&gt; &lt;img src="img/ad001.png" alt="2015年度报告"&gt;&lt;/picture&gt; 这里还可以利用source去添加对于不同格式图片的匹配。123&lt;source media="(max-width:36em)" srcset="img/480.png 480w"/&gt;&lt;source srcset="img/960.png 960w"/&gt;&lt;img src="img/ad001-l.png"&gt; 方法5：使用svg图片优点：缩放时不会变形；兼容性方面比picture和source要好得多。缺点：与位图相比，很难去表现色彩丰富的图片 Small Tips section和article：section比article更广泛的一些，只要是需要出现的页面大纲中的区块都可以使用section，而article更语义化一些（nav也是），是某些具有图文信息的section，不确定的时候就用sectionb仅仅代表加粗，不代表任何重点；em代表重点强调；i代表这段话有不同的语义，使用了一些譬如反讽的技巧等 定义样式一般使用class，class名一般都用小写，用中横线来分隔不同的单词；id都使用首字母小写的驼峰式写法 如果用户禁用样式，那么使用css中的background定义图片就看不到了 传统的css reset会把所有的页面的样式全部清除，而且会有大量的继承链，而normalize.css较于css reset保护了有价值的部分css，还修复了许多移动端和pc的呈现的bug px可以针对设计稿比较精确地的还原，但是在响应式设计中显得力不从心，因此设计稿大多都是一个样式的示意，在改变屏幕大小的时候会有很多变化em是相对的长度单位，相对的参照物是父元素的font-size，具有继承的特点，当父元素都没有设置font-size时，会一直找到html元素，浏览器会有一个默认的设置：1em=16px，即相当于html的font-size设置为100%rem相对的参照物就是html的fonti-size，默认也是1em=16px，一般html的font-size设置为62.5%，比较好计算，即1rem=10px，但是浏览器兼容性有点问题，低版本IE不支持，所以如果要兼容IE8等，可以再多写一个px单位来兼容 用于隐藏文本，便于SEO和网页阅读器，0/0 a分别代表font-size、font-height和字体（a拿来充个数），transparent表示透明 1234567.text-hide &#123; font: 0/0 a; color: transparent; text-shadow: none; background-color: transparent; border: 0;&#125; @media媒体查询的级别很高，所以它的rem不是针对html的font-size，而是始终针对浏览器默认的font-size：1rem=16px，所以在媒体查询里直接使用兼容性更好的em比较好 polyfill解决浏览器兼容性的妮子，针对响应式图片用的最多的是picturefill 1234567&lt;div class="item"&gt; &lt;picture&gt; &lt;source srcset="img/ad001-l.png" media="(min-width:50em)"&gt; &lt;source srcset="img/ad001-m.png" media="(min-width:30em)"&gt; &lt;img src="img/ad001.png" alt="2015年度报告"&gt; &lt;/picture&gt;&lt;/div&gt; 使用picturefill来抹平picture、dpr等兼容性问题，Picturefill增加了对响应图像解决方案，包括图像元素和新的img元素属性的整个套件的支持。（需要在HTML文档头部引用js库） 使用html5shiv让老的浏览器去支持html5的新标签使用方法： 123&lt;!--[if lt IE9]&gt;&lt;script src=”https://cdn.bootcss.com/html5shiv/r29/html5.js ”&gt;&lt;/script&gt;&lt; ![endif]--&gt; 将上代码复制到head部分，记住一定要是head部分（因为IE必须在元素解析前知道这个元素，所以这个js文件不能在其他位置调用，否则失效）然后在css中加入：12/*html5*/article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block&#125; 实现原理：让这些html5标签成块状和div一样此外还可以通过JavaScript定制需要支持的html5元素，通过在head中并且在引入html5shiv之前插入以下代码12345678910&lt;!--[if lt IE 9]&gt;&lt;script&gt; window.html5 = &#123; 'elements': 'abbr article custom elements', 'shivCSS': true, 'shivMethods': true &#125;;&lt;/script&gt;&lt;script src="html5shiv.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 其中elements的属性值是html5元素标签，可以是由空格分隔的字符串或数组；shivCSS的属性类型为Boolean，默认为true，给html5元素添加CSS样式；shivMethods的属性类型为Boolean，默认为true，覆盖createElement和createDocumentFragment方法。 需要用到的语义化元素很少？那我们就自己来实现html5shivhead中：1234567891011&lt;!--[if lt IE 9]&gt; &lt;script&gt; ;(function()&#123; var elements = ['section','header','footer','article']; var i; for(i in elements)&#123; document.createElement(elements[i]); &#125; &#125;)(); &lt;/script&gt;&lt;![endif]--&gt; css中：123&lt;style&gt; section, header, footer, article &#123;display: block&#125;&lt;/style&gt; IE6-8不支持媒体查询，可以引入repond库，使其支持min-width和max-width这两个特性使用方法：引入respond.min.js即可，但是要在css的后面。实现思路：1.把head中所有的css路径取出来放入数组2.然后遍历数组一个个发ajax请求3.ajax回调后仅分析response中的media query的min-width和max-width语法，分析出viewport变化区间对应相应的css块4.页面初始化时和window.resize时，根据当前viewport使用相应的css块。 modernizr：用来进行防御性编程，来进行兼容性检测当你在网页中嵌入Modernizr的脚本时，它会检测当前浏览器是否支持CSS3的特性，比如 @font-face、border-radius、 border-image、box-shadow、rgba() 等，同时也会检测是否支持HTML5的特性——比如audio、video、本地储存、和新的input标签的类型和属性等。在获取到这些信息的基础上，你可以在那些支持这些功能的浏览器上使用它们，来决定是否创建一个基于JS的fallback，或者对那些不支持的浏览器进行简单的优雅降级。另外，Modernizr还可以令IE支持对HTML5的元素应用CSS样式，这样开发者就可以立即使用这些更富有语义化的标签了。（这样咱们就不需要上面提到的html5shiv了）此外在Modernizr 2.0版中， 它增加了一个针对JavaScript和CSS的条件资源加载器(conditional resource loader)。该资源加载器接受三个参数，第一个是表达式，列举了所需的特性。第二个参数是如果表达式返回true则加载的JavaScript和 CSS文件列表。第三个参数是所需特性不存在的情况下备用的文件列表。除了优雅降级，加载器还可用于引入polyfill。（又可以用到上面的知识）Modernizr是基于渐进增强理论来开发的，所以它支持并鼓励开发者一层一层的创建他们的网站。一切从一个应用了Javascript的空闲地基开始，一个接一个的添加增强的应用层。因为使用了Modernizr，所以你容易知道浏览器都支持什么。工作原理：Modernizr 会在页面加载后立即检测特性；然后创建一个包含检测结果的 JavaScript 对象，同时在 html 元素加入方便你调整 CSS 的 class 名。 browser-sync：多个设备上进行同步调试browser-sync start 实例：browser-sync start –server –port 1234–port 指定要使用的端口–files 文件路径–server 运行本地服务器]]></content>
      <categories>
        <category>作品</category>
      </categories>
      <tags>
        <tag>responsive</tag>
        <tag>WebDemo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个手机阅读器的WebApp]]></title>
    <url>%2FiReader.html</url>
    <content type="text"><![CDATA[提问：拿着手机我们都该干点啥正经事儿？ 按照惯例，咱也还是先上效果图。有句名言说得好：没图说个脚本:)还有一句名言叫做：talk is to easy, show me the code!So 接下来咱们就开始看看这个小东西里面都有哪些重难点。 HTML页面部分这部分还比较常规，没有特别需要注意或者说新颖的地方，有几个小tips看一下就好了。 因为作品是针对手机端的一个WebApp，所以为了让这个WebApp看起来更像是一个Native App，我们需要在页面部分的meta处声明以下代码，作用分别是：设备宽度等于视口宽度即使布局视口等于可视视口，这样布局视口就成为了理想视口；最小缩放1倍；最大缩放1倍；禁止用户缩放； 1&lt;meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; JS部分一、第三方库的选择和使用需要用到的第三方库有jQuery.base64.js、jQuery.jsonp.js，分别用来进行base64格式图片的获取以及jsonp的使用，此外在这里我是用了Zepto.js而不是jQuery作为前两个库的支持，这是因为在移动端的性能表现上，Zepto比jQuery稍微优秀一些，也正因如此在js文件引用时需要做那么一些小改动。1234567&lt;script type="text/javascript" src="lib/zepto.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; window.jQuery = $;&lt;/script&gt;&lt;script type="text/javascript" src="js/jquery.base64.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/jquery.jsonp.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/index.js"&gt;&lt;/script&gt; 一定要注意调用的顺序，zepto.js要最先调用。 知识拓展：jQuery与Zepto的异同相同点：Zepto最初是为移动端开发的库，是jQuery的轻量级替代品，因为它的API和jQuery相似，而文件更小。Zepto最大的优势是它的文件大小，只有8k多，是目前功能完备的库中最小的一个，尽管不大，Zepto所提供的工具足以满足开发程序的需要。大多数在jQuery中·常用的API和方法Zepto都有，Zepto中还有一些jQuery中没有的。另外，因为Zepto的API大部分都能和jQuery兼容，所以用起来极其容易，如果熟悉jQuery，就能很容易掌握Zepto。你可用同样的方式重用jQuery中的很多方法，也可以方面地把方法串在一起得到更简洁的代码，甚至不用看它的文档。不同点： 针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。 width()和height()的区别：Zepto由盒模型(box-sizing)决定，用.width()返回赋值的width，用.css(‘width’)返回加border等的结果；jQuery会忽略盒模型，始终返回内容区域的宽/高(不包含padding、border)。 offset()的区别：Zepto返回{top,left,width,height}；jQuery返回{width,height}。 Zepto无法获取隐藏元素宽高，jQuery 可以。 Zepto中没有为原型定义extend方法而jQuery有。 Zepto的each方法只能遍历数组，不能遍历JSON对象。 事件委托差异： 12345678var $doc = $(document);$doc.on('click', '.a', function () &#123; alert('a事件'); $(this).removeClass('a').addClass('b');&#125;);$doc.on('click', '.b', function () &#123; alert('b事件');&#125;); 在Zepto中，当a被点击后，依次弹出了内容为”a事件“和”b事件“，说明虽然事件委托在.a上可是却也触发了.b上的委托。但是在 jQuery 中只会触发.a上面的委托弹出”a事件“。Zepto中，document上所有的click委托事件都依次放入到一个队列中，点击的时候先看当前元素是不是.a，符合则执行，然后查看是不是.b，符合则执行。而在jQuery中，document上委托了2个click事件，点击后通过选择符进行匹配，执行相应元素的委托事件。二、HTML5的本地存储作品中的各项设置都是可以保存到本地，这样在下次登录刷新时会自动获取上次的设置。这里主要是用了HTML5的LocalStorage12345678// 存储相关var prefix = 'iReader_';var StorageGetter = function(key) &#123; return localStorage.getItem(prefix + key);&#125;;var StorageSetter = function(key,value) &#123; return localStorage.setItem(prefix + key,value);&#125;; 知识拓展：HTML5的本次存储本地存储是一个window的属性，包括localStorage和sessionStorage，从名字应该可以很清楚的辨认二者的区别，前者是一直存在本地的，后者只是伴随着session，窗口一旦关闭就没了。二者用法完全相同，这里以localStorage为例。大小大概为5M。比Cookie的4KB好得多。存储数据的方法就是给window.localStorage添加一个属性，属性都是以键值对的方式存在：1234567localStorage.a = 3;//设置a为"3"localStorage["a"] = "sfsf";//设置a为"sfsf"，覆盖上面的值localStorage.setItem("b","isaac");//设置b为"isaac"var a1 = localStorage["a"];//获取a的值var a2 = localStorage.a;//获取a的值var b = localStorage.getItem("b");//获取b的值localStorage.removeItem("c");//清除c的值 推荐使用getItem()和setItem()，清除键值对使用removeItem()，一次性清除所有键值对使用clear()。此外还有key()方法在不知道有哪些键值的时候进行使用。Note: HTML5本地存储只能存字符串，任何格式存储的时候都会被自动转为字符串，所以读取的时候，需要自己进行类型的转换。三、跨刘浏览器的事件绑定这里主要是因为有DOM0级、DOM2级以及IE事件存在导致的。123456789101112131415161718// 跨浏览器的事件绑定var addHandler = function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on"+type, handler); &#125; else&#123; element["on"+type] = handler; &#125;&#125;;var getEvent = function(event) &#123; return event? event:window.event;&#125;;var getTarget = function(event) &#123; return event.target || event.srcElement;&#125;; 知识拓展（文本后面的PXXX代表内容位于JavaScript高级程序设计书中的页面）DOM0级事件处理程序（最为传统的方式，至今仍都在支持）：每个元素都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick，将这些属性的值设置为一个函数，如btn.onclick=function(){};如要删除，则将值置为null，如btn.onclick=nullDOM2级事件处理程序：使用addEventListener()和removeEventListener()实现，接受三个参数：事件名（如click）、处理程序、布尔值（true为捕获阶段，false为冒泡阶段，通常为了兼容浏览器，使用false）。注：通过addEventListener()添加的匿名函数将无法移除。同一按钮添加多个事件，顺序执行IE事件处理程序：使用attachEvent()和detachEvent()实现，接受两个参数：事件名（如onclick）、处理程序。同一添加多个事件，逆序执行。（p353）DOM中（包括DOM0和DOM2）事件使用event、事件目标event.target、阻止默认行为preventDefault()方法（cancelable属性要为true）、取消事件捕获或者冒泡stopPropagation()IE中事件使用window.event、事件目标window.event.srcElement、阻止默认行为returnValue=false、取消事件冒泡cancelBubble=true（p361）四、从书城官网获取图书数据123456789101112131415// JSONPlet getJSONP = function(url,callback) &#123; return $.jsonp(&#123; url:url, cache:true, callback:"duokan_fiction_chapter", success:function(result) &#123; let data = $.base64.decode(result); data = escape(data); let json = decodeURIComponent(data); //debugger; callback(json); &#125; &#125;);&#125;; 这里的图书信息是从多看书城的官网数据库通过jsonp的方式获取的，callback回调需设置为：duokan_fiction_chapter，这个是由多看书城制定的，不能修改。此外拿到的数据需要对其进行base64的解码，然后通过escape()函数对字符串进行编码,这样就可以在所有的计算机上读取该字符串。最后使用decodeURIComponent()进行解码得到结果。 CSS部分使用base64的格式来制作图标12345.icon-font&#123; width: 20px; height:13px; background: url(data:image/png;base64,iVBORw0KGgoAAA94YlwCQTI3MEQiIHN0UmVmO/*后面太长省略*/ background-size:contain; 知识拓展Data URL编码图片：通常在标签中使用图片是采用src属性指定一个远程服务器上的资源。当页面加载时，浏览器会针对每个资源向服务器发送一个请求，一般浏览器并发请求数不能超过4个。因此大量使用会导致页面的加载延迟。使用Data URL将图片以base64字符串的格式嵌入至src属性，则不会产生请求。（IE6/7不支持）优势：当访问外部资源很麻烦或受限时、当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时、当图片的体积太小，占用一个HTTP会话不是很值得时使用。劣势：Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3；Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。如何避免劣势：在CSS中使用Data URL。通过CSS文件中的backround-image属性引用图片url地址：background-image: url(“data:XXX “);他避免了图片单独产生一次HTTP请求，又让图片随CSS被浏览器缓存（所有浏览器都很乐意缓存CSS文件）。如何使用：在线Data URL生成工具、使用HTML5的FileReader()1234567891011var reader = new FileReader();//定义一个FileReadervar content;content = reader.readAsDataURL(localFile, "UTF-8");//readAS…完成后会将相对应的结果保存至result属性中，例如readAsDataURL、readAsText等，随后会调用onload或者onerror事件处理程序reader.onload = function(event) &#123; content = event.target.result; document.getElementById("img").src = content; document.getElementById("fileContent").value = content; &#125;reader.onerror = function(event) &#123; alert('error'); &#125;&#125;]]></content>
      <categories>
        <category>作品</category>
      </categories>
      <tags>
        <tag>WebApp</tag>
        <tag>iReader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用React实现图片画廊（送女朋友必备）]]></title>
    <url>%2Freact-gallery.html</url>
    <content type="text"><![CDATA[提问：程序猿该如何找到女朋友？ 这个小项目用到的主要技术是React以及webpack，历时差不多断断续续三天时间吧，初衷是为了入门react以及对webpack的工作原理有个更深刻的认识，当然其中也遇到了不少难题，现做记录，话不多说了，上效果图。 初识React首先通过React的createClass方法来创建一个React的组件，注意，这里创建的并不是真实的DOM节点:jsx123456var Hello = React.createClass( // 添加function、state等 render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt; &#125;) 在ES6中可以通过class Hello extends React.Component{}，来实现创建React组件；用render(){}来替代render:function(){}然后通过调用React的render方法来创建一个组件的实例：jsx123ReactDOM.render(&lt;Hello name="React!" /&gt;,document.getElementById('container')); 其中render方法接受两个参数，第一个是React的组件，第二个是要插入的DOM节点 。 React生命周期有三个状态： Mounted：组件被render解析生成相对应的DOM节点并被插入浏览器的一个过程 Update： 一个Mounted的组件被重新render的过程（会将当前state和最近一次的state对比，只有发生改变了并且影响了DOM结构才会进行重新渲染） Unmounted：将一个组件对应的DOM节点从DOM结构中移除的过程每个状态都封装了hook函数（钩子函数）:常用的钩子函数： getInitialState()：初始化组件的最初的状态 jsx123getInitialState: function() &#123; return &#123;&#125;; &#125; ES6中可以如下实现：jsx123456class AppComponent extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123;&#125;; &#125;&#125; 注意：调用super的原因：在ES6中，在子类的constructor中必须先调用super才能引用thissuper(props)的目的：在constructor中可以使用this.props componentDidMount():组件被加载后进行的操作 ，否则会报错，创建组件实例时也同理，若需要创建多个，可以用一个标签包裹起来 创建组件时，组件的首字母必须大写，否则既不报错也不会正常显示 创建组件时，render函数内return的标签不是真实的DOM节点，那么要怎么在创建的时候取得标签并对其进行操作呢?答：可以在标签中添加ref属性，然后在方法中通过this.refs.REFNAME来取得该组件（方法中自动封装了event对象）： jsx123456789101112131415var MyComponent = React.createClass(&#123; handleClick: function(event) &#123; this.refs.myTextInput.focus(); event.stopPropagation(); event.preventDefault(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type="text" ref="myTextInput" /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); ————————项目开始————————脚手架工具yeomanyeoman能够自动构建好最佳的代码结构（基于Nodejs）安装：npm i -g yo选择相关的项目生成器：（本项目使用基于webpack来构建react）npm i -g generator-react-webpack查看已安装的generator生成器:1234linux npm ls -g –depth=1 2&gt;/dev/null | grep generator- windows npm ls -g –depth=1 2&gt;/dev/null | findstr generator- 2代表错误消息，/dev/null代表空设备文件，即将错误信息输出到空设备文件上，不显示出来我在windows 下，提示，系统找不到指定的路径。不指定 | findstr generator- ，出了全部的全局一级依赖。生成项目：yo react-webpack react-gallery webpack相关 .jshintrc不能解决jsx的相关问题，所以新版本都使用了.eslintrc（默认包含了.jshintrc） 新版本的webpack.config都模块化的存放在了./cfg目录下 解释：index.html中__REACT_DEVTOOLS_GLOBAL_HOOK__ = parent.__REACT_DEVTOOLS_GLOBAL_HOOK__因为使用React DevTool时，正常的React页面可以直接和ReactDevTools进行通信，但是在使用webpack的热更新时，webpack是将渲染出来的DOM结构以一个iframe进行呈现，所以需要将global环境下的hook赋值给iframe中的hook，才能保证正常通信。 新版本webpack中自动配置了json-loader无需另外配置 项目开始 图片旋转时，需要考虑浏览器的兼容性，这里必须使用较为特殊的驼峰式命名 jsx1234567//如果图片旋转角度有值，且不为0if(this.props.arrange.rotate)&#123; //对各种浏览器的兼容性，必须用驼峰式命名 ['MozTransform','msTransform','WebkitTransform','transform'].forEach(function(value)&#123; styleObj[value] = 'rotate('+this.props.arrange.rotate+'deg)'; &#125;.bind(this));&#125; 给居中的图片添加z-index，避免遮盖 123456//添加z-index 避免遮盖if(this.props.arrange.isCenter)&#123; styleObj.zIndex = 11;&#125; else &#123; styleObj.zIndex = 0;&#125; 图片样式中的transform-style/perspective/transform-origintransform-style属性是3D空间一个重要属性，指定嵌套元素如何在3D空间中呈现。他主要有两个属性值：flat和preserve-3d。其中flat值为默认值，表示所有子元素在2D平面呈现。preserve-3d表示所有子元素在3D空间中呈现。perspective属性对于3D变形来说至关重要。该属性会设置查看者的位置，并将可视内容映射到一个视锥上，继而投到一个2D视平面上。如果不指定透视，则Z轴空间中的所有点将平铺到同一个2D视平面中，并且变换结果中将不存在景深概念。上面的描述可能让人难以理解一些，其实对于perspective属性，我们可以简单的理解为视距，用来设置用户和元素3D空间Z平面之间的距离。而其效应由他的值来决定，值越小，用户与3D空间Z平面距离越近，视觉效果更令人印象深刻；反之，值越大，用户与3D空间Z平面距离越远，视觉效果就很小。transform-origin: 0 50% 0; /*将旋转中心定为左线（默认值是中心点 50% 50% 0）*/ 接上条，因为使用了transform-style:3d诱发了一个在Safari中的旋转bug翻转了图片之后img-front被旋转了180盖在了img-back之上，正常情况下应该是img-back在上如下图：解决方法：添加transformZ(1px)给他一个Z轴上的位移，让它盖住img-front。 在Safari的Retina显示屏下，nav中的图表不清晰亮色字体在深色的背景下渲染会显得粗糙，因为使用的亚像素渲染（使用RGB混合来呈现，较灰阶渲染效果更好，消耗内存也更多，手机上没有采用，mac上大量采用），因此要开启灰阶渲染（控制轮廓上像素点的亮度来达到字体原始形状） 12-webkit-font-smoothing: antialiased;-moz-font-smoothing: grayscale; 详细解释：&emsp;&emsp;理想的字体其边缘的过渡是非常平滑的，但是在屏幕上显示的时候需要将字体栅格化为一个个像素点，采用黑白像素点渲染，无法体现字体的细节之处，会造成边缘呈现锯齿状的不平滑。&emsp;&emsp;为了解决这个问题，字体渲染引擎采用了一些方法去进行平滑，其中就包括灰阶渲染和亚像素渲染&emsp;&emsp;灰阶渲染是通过控制字体轮廓上像素点的亮度，达到字体原始形状的方法&emsp;&emsp;亚像素渲染则利用了LCD屏幕中每个像素是由RGB三个亚像素的颜色和亮度混合而成一个完整像素的颜色这一原理，将字体上的轮廓点由三个亚像素体现达到原始形状的方法，与灰阶渲染相比，分辨率在垂直方向上放大了三倍，因此，渲染效果更好。但是，所消耗的内存也更多。&emsp;&emsp;因此在手机屏幕上，为了减少CPU的开销，使用灰阶渲染。但是在macOS操作系统上，采用的是亚像素渲染这种方式。这会导致白色、亮色的字体，在深色背景下会显得过粗，严重情况下看上去会模糊。]]></content>
      <categories>
        <category>作品</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>webpack</tag>
        <tag>gallery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个脚印]]></title>
    <url>%2FHello-World.html</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;我是陈凯鑫，熟悉的朋友都爱叫我开心。&emsp;&emsp;我是一个默默走在代码漫漫长路上的乐观积极的前端er。&emsp;&emsp;没有太多的天赋，因为热爱，所以坚持。&emsp;&emsp;渴望学习，同时也乐于分享。&emsp;&emsp;非常欢迎大家访问我的GitHub，里面有我的一些学习和自己创作的小作品 一个基于react和webpack的画廊小作品 一个手机阅读器的WebApp 一个响应式的WebDemo 一个基于Vue1.0的外卖WebApp &emsp;&emsp;接下来最开始的几篇博客我就来写一写做这些小作品的时候遇到的坑和一些重难点吧]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>for fun</tag>
      </tags>
  </entry>
</search>
